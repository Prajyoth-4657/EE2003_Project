Compiling sources for behavioural simulation
Ensure all required files listed in program_files_behav.txt
RUNNING TEST 
PASSED

Passed
Running yosys to synthesize cpu.
Ensure that 'synth.ys' lists all the modules needed for the synthesis,
and that the top module is called 'cpu'

 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9 (git sha1 1979e0b)


-- Executing script file `synth.ys' --

1. Executing Verilog-2005 frontend: cpu.v
Parsing Verilog input from `cpu.v' to AST representation.
Generating RTLIL representation for module `\cpu'.
Successfully finished Verilog frontend.

2. Executing Verilog-2005 frontend: alu.v
Parsing Verilog input from `alu.v' to AST representation.
Generating RTLIL representation for module `\alu'.
Successfully finished Verilog frontend.

3. Executing Verilog-2005 frontend: dummydecoder.v
Parsing Verilog input from `dummydecoder.v' to AST representation.
Generating RTLIL representation for module `\dummydecoder'.
Successfully finished Verilog frontend.

4. Executing Verilog-2005 frontend: regfile.v
Parsing Verilog input from `regfile.v' to AST representation.
Generating RTLIL representation for module `\regfile'.
Successfully finished Verilog frontend.

5. Executing SYNTH_XILINX pass.

5.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_sim.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\VCC'.
Generating RTLIL representation for module `\GND'.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\OBUF'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGCTRL'.
Generating RTLIL representation for module `\BUFHCE'.
Generating RTLIL representation for module `\INV'.
Generating RTLIL representation for module `\LUT1'.
Generating RTLIL representation for module `\LUT2'.
Generating RTLIL representation for module `\LUT3'.
Generating RTLIL representation for module `\LUT4'.
Generating RTLIL representation for module `\LUT5'.
Generating RTLIL representation for module `\LUT6'.
Generating RTLIL representation for module `\LUT6_2'.
Generating RTLIL representation for module `\MUXCY'.
Generating RTLIL representation for module `\MUXF7'.
Generating RTLIL representation for module `\MUXF8'.
Generating RTLIL representation for module `\XORCY'.
Generating RTLIL representation for module `\CARRY4'.
Generating RTLIL representation for module `\FDRE'.
Generating RTLIL representation for module `\FDSE'.
Generating RTLIL representation for module `\FDCE'.
Generating RTLIL representation for module `\FDPE'.
Generating RTLIL representation for module `\FDRE_1'.
Generating RTLIL representation for module `\FDSE_1'.
Generating RTLIL representation for module `\FDCE_1'.
Generating RTLIL representation for module `\FDPE_1'.
Generating RTLIL representation for module `\RAM32X1D'.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM128X1D'.
Generating RTLIL representation for module `\SRL16E'.
Generating RTLIL representation for module `\SRLC32E'.
Successfully finished Verilog frontend.

5.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_xtra.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_xtra.v' to AST representation.
Generating RTLIL representation for module `\BSCANE2'.
Generating RTLIL representation for module `\BUFGCE'.
Generating RTLIL representation for module `\BUFGCE_1'.
Generating RTLIL representation for module `\BUFGMUX'.
Generating RTLIL representation for module `\BUFGMUX_1'.
Generating RTLIL representation for module `\BUFGMUX_CTRL'.
Generating RTLIL representation for module `\BUFH'.
Generating RTLIL representation for module `\BUFIO'.
Generating RTLIL representation for module `\BUFMR'.
Generating RTLIL representation for module `\BUFMRCE'.
Generating RTLIL representation for module `\BUFR'.
Generating RTLIL representation for module `\CAPTUREE2'.
Generating RTLIL representation for module `\CFGLUT5'.
Generating RTLIL representation for module `\DCIRESET'.
Generating RTLIL representation for module `\DNA_PORT'.
Generating RTLIL representation for module `\DSP48E1'.
Generating RTLIL representation for module `\EFUSE_USR'.
Generating RTLIL representation for module `\FIFO18E1'.
Generating RTLIL representation for module `\FIFO36E1'.
Generating RTLIL representation for module `\FRAME_ECCE2'.
Generating RTLIL representation for module `\GTHE2_CHANNEL'.
Generating RTLIL representation for module `\GTHE2_COMMON'.
Generating RTLIL representation for module `\GTPE2_CHANNEL'.
Generating RTLIL representation for module `\GTPE2_COMMON'.
Generating RTLIL representation for module `\GTXE2_CHANNEL'.
Generating RTLIL representation for module `\GTXE2_COMMON'.
Generating RTLIL representation for module `\IBUF_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\IBUFDS_GTE2'.
Generating RTLIL representation for module `\IBUFDS_IBUFDISABLE'.
Generating RTLIL representation for module `\IBUFDS_INTERMDISABLE'.
Generating RTLIL representation for module `\ICAPE2'.
Generating RTLIL representation for module `\IDDR'.
Generating RTLIL representation for module `\IDDR_2CLK'.
Generating RTLIL representation for module `\IDELAYCTRL'.
Generating RTLIL representation for module `\IDELAYE2'.
Generating RTLIL representation for module `\IN_FIFO'.
Generating RTLIL representation for module `\IOBUF'.
Generating RTLIL representation for module `\IOBUF_DCIEN'.
Generating RTLIL representation for module `\IOBUF_INTERMDISABLE'.
Generating RTLIL representation for module `\IOBUFDS'.
Generating RTLIL representation for module `\IOBUFDS_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_DCIEN'.
Generating RTLIL representation for module `\IOBUFDS_DIFF_OUT_INTERMDISABLE'.
Generating RTLIL representation for module `\ISERDESE2'.
Generating RTLIL representation for module `\KEEPER'.
Generating RTLIL representation for module `\LDCE'.
Generating RTLIL representation for module `\LDPE'.
Generating RTLIL representation for module `\MMCME2_ADV'.
Generating RTLIL representation for module `\MMCME2_BASE'.
Generating RTLIL representation for module `\OBUFDS'.
Generating RTLIL representation for module `\OBUFT'.
Generating RTLIL representation for module `\OBUFTDS'.
Generating RTLIL representation for module `\ODDR'.
Generating RTLIL representation for module `\ODELAYE2'.
Generating RTLIL representation for module `\OSERDESE2'.
Generating RTLIL representation for module `\OUT_FIFO'.
Generating RTLIL representation for module `\PHASER_IN'.
Generating RTLIL representation for module `\PHASER_IN_PHY'.
Generating RTLIL representation for module `\PHASER_OUT'.
Generating RTLIL representation for module `\PHASER_OUT_PHY'.
Generating RTLIL representation for module `\PHASER_REF'.
Generating RTLIL representation for module `\PHY_CONTROL'.
Generating RTLIL representation for module `\PLLE2_ADV'.
Generating RTLIL representation for module `\PLLE2_BASE'.
Generating RTLIL representation for module `\PS7'.
Generating RTLIL representation for module `\PULLDOWN'.
Generating RTLIL representation for module `\PULLUP'.
Generating RTLIL representation for module `\RAM128X1S'.
Generating RTLIL representation for module `\RAM256X1S'.
Generating RTLIL representation for module `\RAM32M'.
Generating RTLIL representation for module `\RAM32X1S'.
Generating RTLIL representation for module `\RAM32X1S_1'.
Generating RTLIL representation for module `\RAM32X2S'.
Generating RTLIL representation for module `\RAM64M'.
Replacing existing blackbox module `\RAM64X1D' at /usr/bin/../share/yosys/xilinx/cells_xtra.v:3741.
Generating RTLIL representation for module `\RAM64X1D'.
Generating RTLIL representation for module `\RAM64X1S'.
Generating RTLIL representation for module `\RAM64X1S_1'.
Generating RTLIL representation for module `\RAM64X2S'.
Generating RTLIL representation for module `\ROM128X1'.
Generating RTLIL representation for module `\ROM256X1'.
Generating RTLIL representation for module `\ROM32X1'.
Generating RTLIL representation for module `\ROM64X1'.
Generating RTLIL representation for module `\STARTUPE2'.
Generating RTLIL representation for module `\USR_ACCESSE2'.
Generating RTLIL representation for module `\XADC'.
Successfully finished Verilog frontend.

5.3. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/brams_bb.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/brams_bb.v' to AST representation.
Generating RTLIL representation for module `\RAMB18E1'.
Generating RTLIL representation for module `\RAMB36E1'.
Successfully finished Verilog frontend.

5.4. Executing HIERARCHY pass (managing design hierarchy).

5.4.1. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \dummydecoder
Used module:     \regfile
Used module:     \alu

5.4.2. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \dummydecoder
Used module:     \regfile
Used module:     \alu
Removed 0 unused modules.

5.5. Executing SYNTH pass.

5.5.1. Executing PROC pass (convert processes to netlists).

5.5.1.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

5.5.1.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$regfile.v:28$117 in module regfile.
Marked 2 switch rules as full_case in process $proc$dummydecoder.v:12$48 in module dummydecoder.
Removed 3 dead cases from process $proc$alu.v:22$24 in module alu.
Marked 7 switch rules as full_case in process $proc$alu.v:22$24 in module alu.
Marked 8 switch rules as full_case in process $proc$cpu.v:75$2 in module cpu.
Marked 1 switch rules as full_case in process $proc$cpu.v:62$1 in module cpu.
Removed a total of 3 dead cases.

5.5.1.3. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\regfile.$proc$regfile.v:20$161'.
  Set init value: \daddr = 0
Found init rule in `\alu.$proc$alu.v:17$47'.
  Set init value: \dwdata = 0
  Set init value: \dwe = 4'0000

5.5.1.4. Executing PROC_ARST pass (detect async resets in processes).

5.5.1.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\regfile.$proc$regfile.v:20$161'.
     1/66: $2\daddr[31:0]
     2/66: $0\i[31:0]
     3/66: $0$memwr$\Reg$regfile.v:22$115_DATA[31:0]$225
     4/66: $0$memwr$\Reg$regfile.v:22$115_ADDR[31:0]$224
     5/66: $0$memwr$\Reg$regfile.v:22$114_DATA[31:0]$223
     6/66: $0$memwr$\Reg$regfile.v:22$114_ADDR[31:0]$222
     7/66: $0$memwr$\Reg$regfile.v:22$113_DATA[31:0]$221
     8/66: $0$memwr$\Reg$regfile.v:22$113_ADDR[31:0]$220
     9/66: $0$memwr$\Reg$regfile.v:22$112_DATA[31:0]$219
    10/66: $0$memwr$\Reg$regfile.v:22$112_ADDR[31:0]$218
    11/66: $0$memwr$\Reg$regfile.v:22$111_DATA[31:0]$217
    12/66: $0$memwr$\Reg$regfile.v:22$111_ADDR[31:0]$216
    13/66: $0$memwr$\Reg$regfile.v:22$110_DATA[31:0]$215
    14/66: $0$memwr$\Reg$regfile.v:22$110_ADDR[31:0]$214
    15/66: $0$memwr$\Reg$regfile.v:22$109_DATA[31:0]$213
    16/66: $0$memwr$\Reg$regfile.v:22$109_ADDR[31:0]$212
    17/66: $0$memwr$\Reg$regfile.v:22$108_DATA[31:0]$211
    18/66: $0$memwr$\Reg$regfile.v:22$108_ADDR[31:0]$210
    19/66: $0$memwr$\Reg$regfile.v:22$107_DATA[31:0]$209
    20/66: $0$memwr$\Reg$regfile.v:22$107_ADDR[31:0]$208
    21/66: $0$memwr$\Reg$regfile.v:22$106_DATA[31:0]$207
    22/66: $0$memwr$\Reg$regfile.v:22$106_ADDR[31:0]$206
    23/66: $0$memwr$\Reg$regfile.v:22$105_DATA[31:0]$205
    24/66: $0$memwr$\Reg$regfile.v:22$105_ADDR[31:0]$204
    25/66: $0$memwr$\Reg$regfile.v:22$104_DATA[31:0]$203
    26/66: $0$memwr$\Reg$regfile.v:22$104_ADDR[31:0]$202
    27/66: $0$memwr$\Reg$regfile.v:22$103_DATA[31:0]$201
    28/66: $0$memwr$\Reg$regfile.v:22$103_ADDR[31:0]$200
    29/66: $0$memwr$\Reg$regfile.v:22$102_DATA[31:0]$199
    30/66: $0$memwr$\Reg$regfile.v:22$102_ADDR[31:0]$198
    31/66: $0$memwr$\Reg$regfile.v:22$101_DATA[31:0]$197
    32/66: $0$memwr$\Reg$regfile.v:22$101_ADDR[31:0]$196
    33/66: $0$memwr$\Reg$regfile.v:22$100_DATA[31:0]$195
    34/66: $0$memwr$\Reg$regfile.v:22$100_ADDR[31:0]$194
    35/66: $0$memwr$\Reg$regfile.v:22$99_DATA[31:0]$193
    36/66: $0$memwr$\Reg$regfile.v:22$99_ADDR[31:0]$192
    37/66: $0$memwr$\Reg$regfile.v:22$98_DATA[31:0]$191
    38/66: $0$memwr$\Reg$regfile.v:22$98_ADDR[31:0]$190
    39/66: $0$memwr$\Reg$regfile.v:22$97_DATA[31:0]$189
    40/66: $0$memwr$\Reg$regfile.v:22$97_ADDR[31:0]$188
    41/66: $0$memwr$\Reg$regfile.v:22$96_DATA[31:0]$187
    42/66: $0$memwr$\Reg$regfile.v:22$96_ADDR[31:0]$186
    43/66: $0$memwr$\Reg$regfile.v:22$95_DATA[31:0]$185
    44/66: $0$memwr$\Reg$regfile.v:22$95_ADDR[31:0]$184
    45/66: $0$memwr$\Reg$regfile.v:22$94_DATA[31:0]$183
    46/66: $0$memwr$\Reg$regfile.v:22$94_ADDR[31:0]$182
    47/66: $0$memwr$\Reg$regfile.v:22$93_DATA[31:0]$181
    48/66: $0$memwr$\Reg$regfile.v:22$93_ADDR[31:0]$180
    49/66: $0$memwr$\Reg$regfile.v:22$92_DATA[31:0]$179
    50/66: $0$memwr$\Reg$regfile.v:22$92_ADDR[31:0]$178
    51/66: $0$memwr$\Reg$regfile.v:22$91_DATA[31:0]$177
    52/66: $0$memwr$\Reg$regfile.v:22$91_ADDR[31:0]$176
    53/66: $0$memwr$\Reg$regfile.v:22$90_DATA[31:0]$175
    54/66: $0$memwr$\Reg$regfile.v:22$90_ADDR[31:0]$174
    55/66: $0$memwr$\Reg$regfile.v:22$89_DATA[31:0]$173
    56/66: $0$memwr$\Reg$regfile.v:22$89_ADDR[31:0]$172
    57/66: $0$memwr$\Reg$regfile.v:22$88_DATA[31:0]$171
    58/66: $0$memwr$\Reg$regfile.v:22$88_ADDR[31:0]$170
    59/66: $0$memwr$\Reg$regfile.v:22$87_DATA[31:0]$169
    60/66: $0$memwr$\Reg$regfile.v:22$87_ADDR[31:0]$162
    61/66: $0$memwr$\Reg$regfile.v:22$86_DATA[31:0]$168
    62/66: $0$memwr$\Reg$regfile.v:22$86_ADDR[31:0]$167
    63/66: $0$memwr$\Reg$regfile.v:22$85_DATA[31:0]$166
    64/66: $0$memwr$\Reg$regfile.v:22$85_ADDR[31:0]$165
    65/66: $0$memwr$\Reg$regfile.v:22$84_DATA[31:0]$164
    66/66: $0$memwr$\Reg$regfile.v:22$84_ADDR[31:0]$163
Creating decoders for process `\regfile.$proc$regfile.v:41$122'.
     1/3: $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125
     2/3: $0$memwr$\Reg$regfile.v:44$116_DATA[31:0]$124
     3/3: $0$memwr$\Reg$regfile.v:44$116_ADDR[4:0]$123
Creating decoders for process `\regfile.$proc$regfile.v:28$117'.
     1/4: $1\daddr[31:0]
     2/4: $0\daddr[31:0]
     3/4: $0\rv2[31:0]
     4/4: $0\rv1[31:0]
Creating decoders for process `\dummydecoder.$proc$dummydecoder.v:12$48'.
     1/12: $2\we[0:0]
     2/12: $2\rv2[31:0]
     3/12: $2\op[5:0]
     4/12: $1\we[0:0]
     5/12: $1\rv2[31:0]
     6/12: $1\op[5:0]
     7/12: $0\rd[4:0]
     8/12: $0\rs2[4:0]
     9/12: $0\rs1[4:0]
    10/12: $0\we[0:0]
    11/12: $0\op[5:0]
    12/12: $0\rv2[31:0]
Creating decoders for process `\alu.$proc$alu.v:17$47'.
     1/2: $4\dwe[3:0]
     2/2: $2\dwdata[31:0]
Creating decoders for process `\alu.$proc$alu.v:22$24'.
     1/12: $3\dwe[3:0]
     2/12: $2\dwe[3:0]
     3/12: $5\rvout[31:0]
     4/12: $4\rvout[31:0]
     5/12: $3\rvout[31:0]
     6/12: $2\rvout[31:0]
     7/12: $1\dwdata[31:0]
     8/12: $1\dwe[3:0]
     9/12: $1\rvout[31:0]
    10/12: $0\rvout[31:0]
    11/12: $0\dwe[3:0]
    12/12: $0\dwdata[31:0]
Creating decoders for process `\cpu.$proc$cpu.v:75$2'.
     1/4: $2\iaddr[31:0] [31:1]
     2/4: $2\iaddr[31:0] [0]
     3/4: $1\iaddr[31:0]
     4/4: $0\iaddr[31:0]
Creating decoders for process `\cpu.$proc$cpu.v:62$1'.
     1/6: $1\dwe[3:0]
     2/6: $1\dwdata[31:0]
     3/6: $1\daddr[31:0]
     4/6: $0\daddr[31:0]
     5/6: $0\dwe[3:0]
     6/6: $0\dwdata[31:0]

5.5.1.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\regfile.\i' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$87_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$84_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$84_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$85_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$85_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$86_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$86_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$87_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$88_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$88_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$89_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$89_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$90_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$90_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$91_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$91_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$92_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$92_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$93_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$93_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$94_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$94_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$95_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$95_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$96_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$96_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$97_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$97_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$98_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$98_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$99_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$99_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$100_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$100_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$101_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$101_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$102_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$102_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$103_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$103_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$104_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$104_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$105_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$105_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$106_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$106_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$107_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$107_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$108_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$108_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$109_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$109_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$110_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$110_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$111_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$111_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$112_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$112_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$113_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$113_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$114_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$114_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$115_ADDR' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.$memwr$\Reg$regfile.v:22$115_DATA' from process `\regfile.$proc$regfile.v:20$161'.
No latch inferred for signal `\regfile.\daddr' from process `\regfile.$proc$regfile.v:28$117'.
No latch inferred for signal `\regfile.\rv1' from process `\regfile.$proc$regfile.v:28$117'.
No latch inferred for signal `\regfile.\rv2' from process `\regfile.$proc$regfile.v:28$117'.
No latch inferred for signal `\dummydecoder.\rv2' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\dummydecoder.\op' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\dummydecoder.\rs1' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\dummydecoder.\rs2' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\dummydecoder.\rd' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\dummydecoder.\we' from process `\dummydecoder.$proc$dummydecoder.v:12$48'.
No latch inferred for signal `\alu.\dwdata' from process `\alu.$proc$alu.v:22$24'.
No latch inferred for signal `\alu.\dwe' from process `\alu.$proc$alu.v:22$24'.
No latch inferred for signal `\alu.\rvout' from process `\alu.$proc$alu.v:22$24'.
No latch inferred for signal `\cpu.\dwdata' from process `\cpu.$proc$cpu.v:62$1'.
No latch inferred for signal `\cpu.\dwe' from process `\cpu.$proc$cpu.v:62$1'.
No latch inferred for signal `\cpu.\daddr' from process `\cpu.$proc$cpu.v:62$1'.

5.5.1.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\regfile.$memwr$\Reg$regfile.v:44$116_ADDR' using process `\regfile.$proc$regfile.v:41$122'.
  created $dff cell `$procdff$713' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Reg$regfile.v:44$116_DATA' using process `\regfile.$proc$regfile.v:41$122'.
  created $dff cell `$procdff$714' with positive edge clock.
Creating register for signal `\regfile.$memwr$\Reg$regfile.v:44$116_EN' using process `\regfile.$proc$regfile.v:41$122'.
  created $dff cell `$procdff$715' with positive edge clock.
Creating register for signal `\cpu.\iaddr' using process `\cpu.$proc$cpu.v:75$2'.
  created $dff cell `$procdff$716' with positive edge clock.

5.5.1.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `regfile.$proc$regfile.v:20$161'.
Found and cleaned up 2 empty switches in `\regfile.$proc$regfile.v:41$122'.
Removing empty process `regfile.$proc$regfile.v:41$122'.
Found and cleaned up 1 empty switch in `\regfile.$proc$regfile.v:28$117'.
Removing empty process `regfile.$proc$regfile.v:28$117'.
Found and cleaned up 2 empty switches in `\dummydecoder.$proc$dummydecoder.v:12$48'.
Removing empty process `dummydecoder.$proc$dummydecoder.v:12$48'.
Removing empty process `alu.$proc$alu.v:17$47'.
Found and cleaned up 7 empty switches in `\alu.$proc$alu.v:22$24'.
Removing empty process `alu.$proc$alu.v:22$24'.
Found and cleaned up 8 empty switches in `\cpu.$proc$cpu.v:75$2'.
Removing empty process `cpu.$proc$cpu.v:75$2'.
Found and cleaned up 1 empty switch in `\cpu.$proc$cpu.v:62$1'.
Removing empty process `cpu.$proc$cpu.v:62$1'.
Cleaned up 21 empty switches.

5.5.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module regfile.
<suppressed ~2 debug messages>
Optimizing module dummydecoder.
Optimizing module alu.
<suppressed ~4 debug messages>
Optimizing module cpu.

5.5.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \regfile..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Removed 0 unused cells and 211 unused wires.
<suppressed ~5 debug messages>

5.5.4. Executing CHECK pass (checking for obvious problems).
checking module alu..
checking module cpu..
checking module dummydecoder..
checking module regfile..
found and reported 0 problems.

5.5.5. Executing OPT pass (performing simple optimizations).

5.5.5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
<suppressed ~90 debug messages>
Finding identical cells in module `\cpu'.
<suppressed ~57 debug messages>
Finding identical cells in module `\dummydecoder'.
<suppressed ~474 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 207 cells.

5.5.5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$530.
    dead port 2/2 on $mux $procmux$552.
    dead port 2/2 on $mux $procmux$469.
    dead port 2/2 on $mux $procmux$577.
    dead port 2/2 on $mux $procmux$489.
    dead port 2/2 on $mux $procmux$508.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$668.
    dead port 1/2 on $mux $procmux$699.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/32 on $pmux $procmux$248.
    dead port 2/32 on $pmux $procmux$248.
    dead port 3/32 on $pmux $procmux$248.
    dead port 4/32 on $pmux $procmux$248.
    dead port 5/32 on $pmux $procmux$248.
    dead port 6/32 on $pmux $procmux$248.
    dead port 7/32 on $pmux $procmux$248.
    dead port 8/32 on $pmux $procmux$248.
    dead port 9/32 on $pmux $procmux$248.
    dead port 10/32 on $pmux $procmux$248.
    dead port 11/32 on $pmux $procmux$248.
    dead port 12/32 on $pmux $procmux$248.
    dead port 13/32 on $pmux $procmux$248.
    dead port 14/32 on $pmux $procmux$248.
    dead port 15/32 on $pmux $procmux$248.
    dead port 16/32 on $pmux $procmux$248.
    dead port 17/32 on $pmux $procmux$248.
    dead port 18/32 on $pmux $procmux$248.
    dead port 19/32 on $pmux $procmux$248.
    dead port 20/32 on $pmux $procmux$248.
    dead port 21/32 on $pmux $procmux$248.
    dead port 22/32 on $pmux $procmux$248.
    dead port 23/32 on $pmux $procmux$248.
    dead port 24/32 on $pmux $procmux$248.
    dead port 25/32 on $pmux $procmux$248.
    dead port 26/32 on $pmux $procmux$248.
    dead port 27/32 on $pmux $procmux$248.
    dead port 28/32 on $pmux $procmux$248.
    dead port 29/32 on $pmux $procmux$248.
    dead port 30/32 on $pmux $procmux$248.
    dead port 31/32 on $pmux $procmux$248.
    dead port 1/32 on $pmux $procmux$323.
    dead port 2/32 on $pmux $procmux$323.
    dead port 3/32 on $pmux $procmux$323.
    dead port 4/32 on $pmux $procmux$323.
    dead port 5/32 on $pmux $procmux$323.
    dead port 6/32 on $pmux $procmux$323.
    dead port 7/32 on $pmux $procmux$323.
    dead port 8/32 on $pmux $procmux$323.
    dead port 9/32 on $pmux $procmux$323.
    dead port 10/32 on $pmux $procmux$323.
    dead port 11/32 on $pmux $procmux$323.
    dead port 12/32 on $pmux $procmux$323.
    dead port 13/32 on $pmux $procmux$323.
    dead port 14/32 on $pmux $procmux$323.
    dead port 15/32 on $pmux $procmux$323.
    dead port 16/32 on $pmux $procmux$323.
    dead port 17/32 on $pmux $procmux$323.
    dead port 18/32 on $pmux $procmux$323.
    dead port 19/32 on $pmux $procmux$323.
    dead port 20/32 on $pmux $procmux$323.
    dead port 21/32 on $pmux $procmux$323.
    dead port 22/32 on $pmux $procmux$323.
    dead port 23/32 on $pmux $procmux$323.
    dead port 24/32 on $pmux $procmux$323.
    dead port 25/32 on $pmux $procmux$323.
    dead port 26/32 on $pmux $procmux$323.
    dead port 27/32 on $pmux $procmux$323.
    dead port 28/32 on $pmux $procmux$323.
    dead port 29/32 on $pmux $procmux$323.
    dead port 30/32 on $pmux $procmux$323.
    dead port 31/32 on $pmux $procmux$323.
    dead port 1/32 on $pmux $procmux$285.
    dead port 2/32 on $pmux $procmux$285.
    dead port 3/32 on $pmux $procmux$285.
    dead port 4/32 on $pmux $procmux$285.
    dead port 5/32 on $pmux $procmux$285.
    dead port 6/32 on $pmux $procmux$285.
    dead port 7/32 on $pmux $procmux$285.
    dead port 8/32 on $pmux $procmux$285.
    dead port 9/32 on $pmux $procmux$285.
    dead port 10/32 on $pmux $procmux$285.
    dead port 11/32 on $pmux $procmux$285.
    dead port 12/32 on $pmux $procmux$285.
    dead port 13/32 on $pmux $procmux$285.
    dead port 14/32 on $pmux $procmux$285.
    dead port 15/32 on $pmux $procmux$285.
    dead port 16/32 on $pmux $procmux$285.
    dead port 17/32 on $pmux $procmux$285.
    dead port 18/32 on $pmux $procmux$285.
    dead port 19/32 on $pmux $procmux$285.
    dead port 20/32 on $pmux $procmux$285.
    dead port 21/32 on $pmux $procmux$285.
    dead port 22/32 on $pmux $procmux$285.
    dead port 23/32 on $pmux $procmux$285.
    dead port 24/32 on $pmux $procmux$285.
    dead port 25/32 on $pmux $procmux$285.
    dead port 26/32 on $pmux $procmux$285.
    dead port 27/32 on $pmux $procmux$285.
    dead port 28/32 on $pmux $procmux$285.
    dead port 29/32 on $pmux $procmux$285.
    dead port 30/32 on $pmux $procmux$285.
    dead port 31/32 on $pmux $procmux$285.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 101 multiplexer ports.
<suppressed ~14 debug messages>

5.5.5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
    New ctrl vector for $pmux cell $procmux$590: $auto$opt_reduce.cc:132:opt_mux$718
    New ctrl vector for $pmux cell $procmux$610: { $procmux$629_CMP $auto$opt_reduce.cc:132:opt_mux$738 $auto$opt_reduce.cc:132:opt_mux$736 $auto$opt_reduce.cc:132:opt_mux$734 $auto$opt_reduce.cc:132:opt_mux$732 $auto$opt_reduce.cc:132:opt_mux$730 $auto$opt_reduce.cc:132:opt_mux$728 $auto$opt_reduce.cc:132:opt_mux$726 $auto$opt_reduce.cc:132:opt_mux$724 $auto$opt_reduce.cc:132:opt_mux$722 $procmux$578_CMP $procmux$553_CMP $procmux$617_CMP $procmux$531_CMP $procmux$509_CMP $auto$opt_reduce.cc:132:opt_mux$720 $procmux$612_CMP $procmux$611_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$717: { $procmux$470_CMP $procmux$490_CMP $procmux$591_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$721: { $procmux$620_CMP $procmux$633_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$723: { $procmux$621_CMP $procmux$634_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$725: { $procmux$622_CMP $procmux$630_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$727: { $procmux$623_CMP $procmux$631_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$729: { $procmux$624_CMP $procmux$635_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$731: { $procmux$625_CMP $procmux$636_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$733: { $procmux$626_CMP $procmux$637_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$735: { $procmux$627_CMP $procmux$632_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$737: { $procmux$628_CMP $procmux$638_CMP }
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
    New ctrl vector for $pmux cell $procmux$389: { $auto$opt_reduce.cc:132:opt_mux$740 $procmux$272_CMP }
    New ctrl vector for $pmux cell $procmux$356: { $auto$opt_reduce.cc:132:opt_mux$744 $auto$opt_reduce.cc:132:opt_mux$742 }
    New ctrl vector for $pmux cell $procmux$243: $auto$opt_reduce.cc:132:opt_mux$746
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$739: { $procmux$273_CMP $procmux$274_CMP $procmux$275_CMP $procmux$276_CMP $procmux$277_CMP $procmux$278_CMP $procmux$279_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$741: { $procmux$249_CMP $procmux$259_CMP $procmux$260_CMP $procmux$261_CMP $procmux$262_CMP $procmux$263_CMP $procmux$264_CMP $procmux$265_CMP $procmux$266_CMP $procmux$267_CMP $procmux$268_CMP $procmux$269_CMP $procmux$270_CMP $procmux$271_CMP $procmux$272_CMP $procmux$273_CMP $procmux$274_CMP $procmux$275_CMP $procmux$276_CMP $procmux$277_CMP $procmux$278_CMP $procmux$279_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$743: { $procmux$250_CMP $procmux$251_CMP $procmux$252_CMP $procmux$253_CMP $procmux$254_CMP $procmux$255_CMP $procmux$256_CMP $procmux$257_CMP $procmux$258_CMP }
    New input vector for $reduce_or cell $auto$opt_reduce.cc:126:opt_mux$745: { $procmux$244_CMP $procmux$245_CMP $procmux$246_CMP }
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
    New input vector for $reduce_or cell $procmux$241_ANY: { $procmux$241_CMP [0] $procmux$241_CMP [1] $procmux$241_CMP [2] $procmux$241_CMP [3] $procmux$241_CMP [4] }
    New input vector for $reduce_or cell $procmux$240_ANY: { $procmux$240_CMP [0] $procmux$240_CMP [1] $procmux$240_CMP [2] }
    Consolidated identical input bits for $mux cell $procmux$226:
      Old ports: A=0, B=32'11111111111111111111111111111111, Y=$procmux$226_Y
      New ports: A=1'0, B=1'1, Y=$procmux$226_Y [0]
      New connections: $procmux$226_Y [31:1] = { $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] $procmux$226_Y [0] }
  Optimizing cells in module \regfile.
    Consolidated identical input bits for $mux cell $procmux$228:
      Old ports: A=0, B=$procmux$226_Y, Y=$0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125
      New ports: A=1'0, B=$procmux$226_Y [0], Y=$0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0]
      New connections: $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [31:1] = { $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] $0$memwr$\Reg$regfile.v:44$116_EN[31:0]$125 [0] }
  Optimizing cells in module \regfile.
Performed a total of 23 changes.

5.5.5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.5.6. Executing OPT_RMDFF pass (remove dff with constant values).

5.5.5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 218 unused wires.
<suppressed ~3 debug messages>

5.5.5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.5.9. Rerunning OPT passes. (Maybe there is more to do..)

5.5.5.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~14 debug messages>

5.5.5.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

5.5.5.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.5.13. Executing OPT_RMDFF pass (remove dff with constant values).

5.5.5.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.5.5.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.5.16. Finished OPT passes. (There is nothing left to do.)

5.5.6. Executing WREDUCE pass (reducing word size of cells).
Removed top 29 bits (of 32) from port B of cell alu.$add$alu.v:103$44 ($add).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$470_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell alu.$procmux$487_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$490_CMP0 ($eq).
Removed top 16 bits (of 32) from mux cell alu.$procmux$506 ($mux).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$509_CMP0 ($eq).
Removed top 24 bits (of 32) from mux cell alu.$procmux$525 ($pmux).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$531_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$553_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$578_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$591_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$617_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$620_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$621_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell alu.$procmux$622_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$623_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$624_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$625_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$626_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$627_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$628_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$629_CMP0 ($eq).
Removed top 2 bits (of 6) from port B of cell alu.$procmux$630_CMP0 ($eq).
Removed top 3 bits (of 6) from port B of cell alu.$procmux$631_CMP0 ($eq).
Removed top 3 bits (of 6) from port B of cell alu.$procmux$632_CMP0 ($eq).
Removed top 3 bits (of 6) from port B of cell alu.$procmux$633_CMP0 ($eq).
Removed top 3 bits (of 6) from port B of cell alu.$procmux$634_CMP0 ($eq).
Removed top 4 bits (of 6) from port B of cell alu.$procmux$635_CMP0 ($eq).
Removed top 4 bits (of 6) from port B of cell alu.$procmux$636_CMP0 ($eq).
Removed top 5 bits (of 6) from port B of cell alu.$procmux$637_CMP0 ($eq).
Removed top 24 bits (of 32) from wire alu.$4\rvout[31:0].
Removed top 16 bits (of 32) from wire alu.$5\rvout[31:0].
Removed top 31 bits (of 32) from wire alu.$lt$alu.v:28$26_Y.
Removed top 31 bits (of 32) from wire alu.$lt$alu.v:29$27_Y.
Removed top 29 bits (of 32) from port B of cell cpu.$add$cpu.v:82$5 ($add).
Removed top 1 bits (of 6) from port B of cell cpu.$procmux$650_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell cpu.$procmux$654_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell cpu.$procmux$658_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell cpu.$procmux$662_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell cpu.$procmux$666_CMP0 ($eq).
Removed top 30 bits (of 32) from mux cell dummydecoder.$ternary$dummydecoder.v:24$50 ($mux).
Removed top 28 bits (of 32) from mux cell dummydecoder.$ternary$dummydecoder.v:23$49 ($mux).
Removed top 27 bits (of 32) from mux cell dummydecoder.$ternary$dummydecoder.v:29$51 ($mux).
Removed top 2 bits (of 7) from port B of cell dummydecoder.$procmux$244_CMP0 ($eq).
Removed top 1 bits (of 7) from port B of cell dummydecoder.$procmux$245_CMP0 ($eq).
Removed top 3 bits (of 10) from port B of cell dummydecoder.$procmux$249_CMP0 ($eq).
Removed top 2 bits (of 10) from port B of cell dummydecoder.$procmux$254_CMP0 ($eq).
Removed top 3 bits (of 10) from port B of cell dummydecoder.$procmux$255_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$256_CMP0 ($eq).
Removed top 2 bits (of 10) from port B of cell dummydecoder.$procmux$257_CMP0 ($eq).
Removed top 4 bits (of 10) from port B of cell dummydecoder.$procmux$258_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$261_CMP0 ($eq).
Removed top 2 bits (of 10) from port B of cell dummydecoder.$procmux$262_CMP0 ($eq).
Removed top 8 bits (of 10) from port B of cell dummydecoder.$procmux$263_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$268_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$269_CMP0 ($eq).
Removed top 2 bits (of 10) from port B of cell dummydecoder.$procmux$270_CMP0 ($eq).
Removed top 4 bits (of 10) from port B of cell dummydecoder.$procmux$271_CMP0 ($eq).
Removed top 2 bits (of 10) from port B of cell dummydecoder.$procmux$273_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$277_CMP0 ($eq).
Removed top 1 bits (of 10) from port B of cell dummydecoder.$procmux$278_CMP0 ($eq).
Removed top 5 bits (of 10) from port B of cell dummydecoder.$procmux$279_CMP0 ($eq).
Removed top 28 bits (of 32) from wire dummydecoder.$ternary$dummydecoder.v:23$49_Y.
Removed top 30 bits (of 32) from wire dummydecoder.$ternary$dummydecoder.v:24$50_Y.
Removed top 27 bits (of 32) from wire dummydecoder.$ternary$dummydecoder.v:29$51_Y.
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$128 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$129 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$130 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$131 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$132 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$133 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$134 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$135 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$136 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$137 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$138 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$139 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$140 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$141 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$142 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$143 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$144 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$145 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$146 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$147 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$148 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$149 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$150 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$151 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$152 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$153 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$154 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$155 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$156 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$157 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$158 (Reg).
Removed top 27 address bits (of 32) from memory init port regfile.$meminit$\Reg$regfile.v:22$159 (Reg).
Removed cell regfile.$procmux$230 ($mux).
Removed cell regfile.$procmux$232 ($mux).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$240_CMP1 ($eq).
Removed cell regfile.$procmux$234 ($mux).
Removed cell regfile.$procmux$236 ($mux).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$240_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$240_CMP2 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$241_CMP0 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$241_CMP1 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$241_CMP2 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$241_CMP3 ($eq).
Removed top 1 bits (of 6) from port B of cell regfile.$procmux$241_CMP4 ($eq).
Removed top 31 bits (of 32) from FF cell regfile.$procdff$715 ($dff).

5.5.7. Executing PEEPOPT pass (run peephole optimizers).

5.5.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 11 unused wires.
<suppressed ~3 debug messages>

5.5.9. Executing TECHMAP pass (map to technology primitives).

5.5.9.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

5.5.9.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~1276 debug messages>

5.5.10. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module alu:
  creating $macc model for $add$alu.v:103$44 ($add).
  creating $macc model for $add$alu.v:106$46 ($add).
  creating $macc model for $add$alu.v:27$25 ($add).
  creating $macc model for $sub$alu.v:36$34 ($sub).
  creating $alu model for $macc $sub$alu.v:36$34.
  creating $alu model for $macc $add$alu.v:27$25.
  creating $alu model for $macc $add$alu.v:106$46.
  creating $alu model for $macc $add$alu.v:103$44.
  creating $alu model for $lt$alu.v:28$26 ($lt): new $alu
  creating $alu model for $lt$alu.v:29$27 ($lt): new $alu
  creating $alu cell for $add$alu.v:103$44: $auto$alumacc.cc:474:replace_alu$756
  creating $alu cell for $add$alu.v:106$46: $auto$alumacc.cc:474:replace_alu$759
  creating $alu cell for $lt$alu.v:29$27: $auto$alumacc.cc:474:replace_alu$762
  creating $alu cell for $lt$alu.v:28$26: $auto$alumacc.cc:474:replace_alu$773
  creating $alu cell for $add$alu.v:27$25: $auto$alumacc.cc:474:replace_alu$786
  creating $alu cell for $sub$alu.v:36$34: $auto$alumacc.cc:474:replace_alu$789
  created 6 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module cpu:
  creating $macc model for $add$cpu.v:81$4 ($add).
  creating $macc model for $add$cpu.v:82$5 ($add).
  creating $macc model for $add$cpu.v:93$21 ($add).
  creating $macc model for $add$cpu.v:94$22 ($add).
  creating $alu model for $macc $add$cpu.v:94$22.
  creating $alu model for $macc $add$cpu.v:93$21.
  creating $alu model for $macc $add$cpu.v:82$5.
  creating $alu model for $macc $add$cpu.v:81$4.
  creating $alu model for $ge$cpu.v:87$12 ($ge): new $alu
  creating $alu model for $ge$cpu.v:91$18 ($ge): new $alu
  creating $alu model for $lt$cpu.v:85$9 ($lt): merged with $ge$cpu.v:87$12.
  creating $alu model for $lt$cpu.v:89$15 ($lt): merged with $ge$cpu.v:91$18.
  creating $alu model for $eq$cpu.v:81$3 ($eq): merged with $ge$cpu.v:91$18.
  creating $alu model for $ne$cpu.v:83$6 ($ne): merged with $ge$cpu.v:91$18.
  creating $alu cell for $ge$cpu.v:91$18, $lt$cpu.v:89$15, $eq$cpu.v:81$3, $ne$cpu.v:83$6: $auto$alumacc.cc:474:replace_alu$794
  creating $alu cell for $ge$cpu.v:87$12, $lt$cpu.v:85$9: $auto$alumacc.cc:474:replace_alu$809
  creating $alu cell for $add$cpu.v:81$4: $auto$alumacc.cc:474:replace_alu$824
  creating $alu cell for $add$cpu.v:82$5: $auto$alumacc.cc:474:replace_alu$827
  creating $alu cell for $add$cpu.v:93$21: $auto$alumacc.cc:474:replace_alu$830
  creating $alu cell for $add$cpu.v:94$22: $auto$alumacc.cc:474:replace_alu$833
  created 6 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module dummydecoder:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module regfile:
  creating $macc model for $add$regfile.v:34$120 ($add).
  creating $macc model for $add$regfile.v:36$121 ($add).
  creating $alu model for $macc $add$regfile.v:36$121.
  creating $alu model for $macc $add$regfile.v:34$120.
  creating $alu cell for $add$regfile.v:34$120: $auto$alumacc.cc:474:replace_alu$836
  creating $alu cell for $add$regfile.v:36$121: $auto$alumacc.cc:474:replace_alu$839
  created 2 $alu and 0 $macc cells.

5.5.11. Executing SHARE pass (SAT-based resource sharing).
Found 3 cells in module alu that may be considered for resource sharing.
  Analyzing resource sharing options for $sshr$alu.v:34$32 ($sshr):
    Found 1 activation_patterns using ctrl signal $auto$opt_reduce.cc:132:opt_mux$728.
    No candidates found.
  Analyzing resource sharing options for $shr$alu.v:35$33 ($shr):
    Found 1 activation_patterns using ctrl signal $auto$opt_reduce.cc:132:opt_mux$726.
    No candidates found.
  Analyzing resource sharing options for $shl$alu.v:33$31 ($shl):
    Found 1 activation_patterns using ctrl signal $auto$opt_reduce.cc:132:opt_mux$736.
    No candidates found.

5.5.12. Executing OPT pass (performing simple optimizations).

5.5.12.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
<suppressed ~6 debug messages>
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.12.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.12.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

5.5.12.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$765: { $auto$alumacc.cc:490:replace_alu$763 [0] $auto$alumacc.cc:490:replace_alu$763 [1] $auto$alumacc.cc:490:replace_alu$763 [2] $auto$alumacc.cc:490:replace_alu$763 [3] $auto$alumacc.cc:490:replace_alu$763 [4] $auto$alumacc.cc:490:replace_alu$763 [5] $auto$alumacc.cc:490:replace_alu$763 [6] $auto$alumacc.cc:490:replace_alu$763 [7] $auto$alumacc.cc:490:replace_alu$763 [8] $auto$alumacc.cc:490:replace_alu$763 [9] $auto$alumacc.cc:490:replace_alu$763 [10] $auto$alumacc.cc:490:replace_alu$763 [11] $auto$alumacc.cc:490:replace_alu$763 [12] $auto$alumacc.cc:490:replace_alu$763 [13] $auto$alumacc.cc:490:replace_alu$763 [14] $auto$alumacc.cc:490:replace_alu$763 [15] $auto$alumacc.cc:490:replace_alu$763 [16] $auto$alumacc.cc:490:replace_alu$763 [17] $auto$alumacc.cc:490:replace_alu$763 [18] $auto$alumacc.cc:490:replace_alu$763 [19] $auto$alumacc.cc:490:replace_alu$763 [20] $auto$alumacc.cc:490:replace_alu$763 [21] $auto$alumacc.cc:490:replace_alu$763 [22] $auto$alumacc.cc:490:replace_alu$763 [23] $auto$alumacc.cc:490:replace_alu$763 [24] $auto$alumacc.cc:490:replace_alu$763 [25] $auto$alumacc.cc:490:replace_alu$763 [26] $auto$alumacc.cc:490:replace_alu$763 [27] $auto$alumacc.cc:490:replace_alu$763 [28] $auto$alumacc.cc:490:replace_alu$763 [29] $auto$alumacc.cc:490:replace_alu$763 [30] $auto$alumacc.cc:490:replace_alu$763 [31] }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$776: { $auto$alumacc.cc:490:replace_alu$774 [0] $auto$alumacc.cc:490:replace_alu$774 [1] $auto$alumacc.cc:490:replace_alu$774 [2] $auto$alumacc.cc:490:replace_alu$774 [3] $auto$alumacc.cc:490:replace_alu$774 [4] $auto$alumacc.cc:490:replace_alu$774 [5] $auto$alumacc.cc:490:replace_alu$774 [6] $auto$alumacc.cc:490:replace_alu$774 [7] $auto$alumacc.cc:490:replace_alu$774 [8] $auto$alumacc.cc:490:replace_alu$774 [9] $auto$alumacc.cc:490:replace_alu$774 [10] $auto$alumacc.cc:490:replace_alu$774 [11] $auto$alumacc.cc:490:replace_alu$774 [12] $auto$alumacc.cc:490:replace_alu$774 [13] $auto$alumacc.cc:490:replace_alu$774 [14] $auto$alumacc.cc:490:replace_alu$774 [15] $auto$alumacc.cc:490:replace_alu$774 [16] $auto$alumacc.cc:490:replace_alu$774 [17] $auto$alumacc.cc:490:replace_alu$774 [18] $auto$alumacc.cc:490:replace_alu$774 [19] $auto$alumacc.cc:490:replace_alu$774 [20] $auto$alumacc.cc:490:replace_alu$774 [21] $auto$alumacc.cc:490:replace_alu$774 [22] $auto$alumacc.cc:490:replace_alu$774 [23] $auto$alumacc.cc:490:replace_alu$774 [24] $auto$alumacc.cc:490:replace_alu$774 [25] $auto$alumacc.cc:490:replace_alu$774 [26] $auto$alumacc.cc:490:replace_alu$774 [27] $auto$alumacc.cc:490:replace_alu$774 [28] $auto$alumacc.cc:490:replace_alu$774 [29] $auto$alumacc.cc:490:replace_alu$774 [30] $auto$alumacc.cc:490:replace_alu$774 [31] }
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
    New input vector for $reduce_or cell $auto$alumacc.cc:509:replace_alu$818: { $auto$rtlil.cc:1864:Xor$815 $auto$rtlil.cc:1835:ReduceAnd$817 }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$799: { $auto$alumacc.cc:490:replace_alu$795 [0] $auto$alumacc.cc:490:replace_alu$795 [1] $auto$alumacc.cc:490:replace_alu$795 [2] $auto$alumacc.cc:490:replace_alu$795 [3] $auto$alumacc.cc:490:replace_alu$795 [4] $auto$alumacc.cc:490:replace_alu$795 [5] $auto$alumacc.cc:490:replace_alu$795 [6] $auto$alumacc.cc:490:replace_alu$795 [7] $auto$alumacc.cc:490:replace_alu$795 [8] $auto$alumacc.cc:490:replace_alu$795 [9] $auto$alumacc.cc:490:replace_alu$795 [10] $auto$alumacc.cc:490:replace_alu$795 [11] $auto$alumacc.cc:490:replace_alu$795 [12] $auto$alumacc.cc:490:replace_alu$795 [13] $auto$alumacc.cc:490:replace_alu$795 [14] $auto$alumacc.cc:490:replace_alu$795 [15] $auto$alumacc.cc:490:replace_alu$795 [16] $auto$alumacc.cc:490:replace_alu$795 [17] $auto$alumacc.cc:490:replace_alu$795 [18] $auto$alumacc.cc:490:replace_alu$795 [19] $auto$alumacc.cc:490:replace_alu$795 [20] $auto$alumacc.cc:490:replace_alu$795 [21] $auto$alumacc.cc:490:replace_alu$795 [22] $auto$alumacc.cc:490:replace_alu$795 [23] $auto$alumacc.cc:490:replace_alu$795 [24] $auto$alumacc.cc:490:replace_alu$795 [25] $auto$alumacc.cc:490:replace_alu$795 [26] $auto$alumacc.cc:490:replace_alu$795 [27] $auto$alumacc.cc:490:replace_alu$795 [28] $auto$alumacc.cc:490:replace_alu$795 [29] $auto$alumacc.cc:490:replace_alu$795 [30] $auto$alumacc.cc:490:replace_alu$795 [31] }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$816: { $auto$alumacc.cc:490:replace_alu$810 [0] $auto$alumacc.cc:490:replace_alu$810 [1] $auto$alumacc.cc:490:replace_alu$810 [2] $auto$alumacc.cc:490:replace_alu$810 [3] $auto$alumacc.cc:490:replace_alu$810 [4] $auto$alumacc.cc:490:replace_alu$810 [5] $auto$alumacc.cc:490:replace_alu$810 [6] $auto$alumacc.cc:490:replace_alu$810 [7] $auto$alumacc.cc:490:replace_alu$810 [8] $auto$alumacc.cc:490:replace_alu$810 [9] $auto$alumacc.cc:490:replace_alu$810 [10] $auto$alumacc.cc:490:replace_alu$810 [11] $auto$alumacc.cc:490:replace_alu$810 [12] $auto$alumacc.cc:490:replace_alu$810 [13] $auto$alumacc.cc:490:replace_alu$810 [14] $auto$alumacc.cc:490:replace_alu$810 [15] $auto$alumacc.cc:490:replace_alu$810 [16] $auto$alumacc.cc:490:replace_alu$810 [17] $auto$alumacc.cc:490:replace_alu$810 [18] $auto$alumacc.cc:490:replace_alu$810 [19] $auto$alumacc.cc:490:replace_alu$810 [20] $auto$alumacc.cc:490:replace_alu$810 [21] $auto$alumacc.cc:490:replace_alu$810 [22] $auto$alumacc.cc:490:replace_alu$810 [23] $auto$alumacc.cc:490:replace_alu$810 [24] $auto$alumacc.cc:490:replace_alu$810 [25] $auto$alumacc.cc:490:replace_alu$810 [26] $auto$alumacc.cc:490:replace_alu$810 [27] $auto$alumacc.cc:490:replace_alu$810 [28] $auto$alumacc.cc:490:replace_alu$810 [29] $auto$alumacc.cc:490:replace_alu$810 [30] $auto$alumacc.cc:490:replace_alu$810 [31] }
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
Performed a total of 5 changes.

5.5.12.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.12.6. Executing OPT_RMDFF pass (remove dff with constant values).

5.5.12.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 3 unused cells and 11 unused wires.
<suppressed ~5 debug messages>

5.5.12.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.12.9. Rerunning OPT passes. (Maybe there is more to do..)

5.5.12.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

5.5.12.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

5.5.12.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.12.13. Executing OPT_RMDFF pass (remove dff with constant values).

5.5.12.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.5.12.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.12.16. Finished OPT passes. (There is nothing left to do.)

5.5.13. Executing FSM pass (extract and optimize FSM).

5.5.13.1. Executing FSM_DETECT pass (finding FSMs in design).

5.5.13.2. Executing FSM_EXTRACT pass (extracting FSM from design).

5.5.13.3. Executing FSM_OPT pass (simple optimizations of FSMs).

5.5.13.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.5.13.5. Executing FSM_OPT pass (simple optimizations of FSMs).

5.5.13.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

5.5.13.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

5.5.13.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

5.5.14. Executing OPT pass (performing simple optimizations).

5.5.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.5.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.5.14.3. Executing OPT_RMDFF pass (remove dff with constant values).

5.5.14.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.5.14.5. Finished fast OPT passes.

5.5.15. Executing MEMORY pass.

5.5.15.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$memwr$\Reg$regfile.v:44$160' in module `\regfile': merged $dff to cell.
Checking cell `$memrd$\Reg$regfile.v:29$118' in module `\regfile': no (compatible) $dff found.
Checking cell `$memrd$\Reg$regfile.v:30$119' in module `\regfile': no (compatible) $dff found.

5.5.15.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 3 unused cells and 3 unused wires.
<suppressed ~4 debug messages>

5.5.15.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

5.5.15.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.5.15.5. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\Reg' in module `\regfile':
  $meminit$\Reg$regfile.v:22$128 ($meminit)
  $meminit$\Reg$regfile.v:22$129 ($meminit)
  $meminit$\Reg$regfile.v:22$130 ($meminit)
  $meminit$\Reg$regfile.v:22$131 ($meminit)
  $meminit$\Reg$regfile.v:22$132 ($meminit)
  $meminit$\Reg$regfile.v:22$133 ($meminit)
  $meminit$\Reg$regfile.v:22$134 ($meminit)
  $meminit$\Reg$regfile.v:22$135 ($meminit)
  $meminit$\Reg$regfile.v:22$136 ($meminit)
  $meminit$\Reg$regfile.v:22$137 ($meminit)
  $meminit$\Reg$regfile.v:22$138 ($meminit)
  $meminit$\Reg$regfile.v:22$139 ($meminit)
  $meminit$\Reg$regfile.v:22$140 ($meminit)
  $meminit$\Reg$regfile.v:22$141 ($meminit)
  $meminit$\Reg$regfile.v:22$142 ($meminit)
  $meminit$\Reg$regfile.v:22$143 ($meminit)
  $meminit$\Reg$regfile.v:22$144 ($meminit)
  $meminit$\Reg$regfile.v:22$145 ($meminit)
  $meminit$\Reg$regfile.v:22$146 ($meminit)
  $meminit$\Reg$regfile.v:22$147 ($meminit)
  $meminit$\Reg$regfile.v:22$148 ($meminit)
  $meminit$\Reg$regfile.v:22$149 ($meminit)
  $meminit$\Reg$regfile.v:22$150 ($meminit)
  $meminit$\Reg$regfile.v:22$151 ($meminit)
  $meminit$\Reg$regfile.v:22$152 ($meminit)
  $meminit$\Reg$regfile.v:22$153 ($meminit)
  $meminit$\Reg$regfile.v:22$154 ($meminit)
  $meminit$\Reg$regfile.v:22$155 ($meminit)
  $meminit$\Reg$regfile.v:22$156 ($meminit)
  $meminit$\Reg$regfile.v:22$157 ($meminit)
  $meminit$\Reg$regfile.v:22$158 ($meminit)
  $meminit$\Reg$regfile.v:22$159 ($meminit)
  $memwr$\Reg$regfile.v:44$160 ($memwr)
  $memrd$\Reg$regfile.v:30$119 ($memrd)
  $memrd$\Reg$regfile.v:29$118 ($memrd)

5.5.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.6. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing regfile.Reg:
  Properties: ports=3 bits=1024 rports=2 wports=1 dbits=32 abits=5 words=32
  Checking rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1):
    Bram geometry: abits=9 dbits=72 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_SDP: awaste=480 dwaste=40 bwaste=35840 waste=35840 efficiency=2
    Rule #1 for bram type $__XILINX_RAMB36_SDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1):
    Bram geometry: abits=9 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_SDP: awaste=480 dwaste=4 bwaste=17408 waste=17408 efficiency=5
    Rule #2 for bram type $__XILINX_RAMB18_SDP (variant 1) rejected: requirement 'min bits 4096' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1):
    Bram geometry: abits=10 dbits=36 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=992 dwaste=4 bwaste=35840 waste=35840 efficiency=2
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2):
    Bram geometry: abits=11 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=2016 dwaste=4 bwaste=36416 waste=36416 efficiency=1
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3):
    Bram geometry: abits=12 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=4064 dwaste=4 bwaste=36704 waste=36704 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4):
    Bram geometry: abits=13 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=8160 dwaste=0 bwaste=32640 waste=32640 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5):
    Bram geometry: abits=14 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=16352 dwaste=0 bwaste=32704 waste=32704 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  Checking rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6):
    Bram geometry: abits=15 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB36_TDP: awaste=32736 dwaste=0 bwaste=32736 waste=32736 efficiency=0
    Rule #3 for bram type $__XILINX_RAMB36_TDP (variant 6) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1):
    Bram geometry: abits=10 dbits=18 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=992 dwaste=4 bwaste=17984 waste=17984 efficiency=2
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 1) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2):
    Bram geometry: abits=11 dbits=9 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=2016 dwaste=4 bwaste=18272 waste=18272 efficiency=1
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 2) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3):
    Bram geometry: abits=12 dbits=4 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=4064 dwaste=0 bwaste=16256 waste=16256 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 3) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4):
    Bram geometry: abits=13 dbits=2 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=8160 dwaste=0 bwaste=16320 waste=16320 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 4) rejected: requirement 'min efficiency 5' not met.
  Checking rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5):
    Bram geometry: abits=14 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAMB18_TDP: awaste=16352 dwaste=0 bwaste=16352 waste=16352 efficiency=0
    Rule #4 for bram type $__XILINX_RAMB18_TDP (variant 5) rejected: requirement 'min efficiency 5' not met.
  No acceptable bram resources found.

5.7. Executing TECHMAP pass (map to technology primitives).

5.7.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/brams_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAMB36_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_SDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB36_TDP'.
Generating RTLIL representation for module `\$__XILINX_RAMB18_TDP'.
Successfully finished Verilog frontend.

5.7.2. Continuing TECHMAP pass.
No more expansions possible.

5.8. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).
Processing regfile.Reg:
  Properties: ports=3 bits=1024 rports=2 wports=1 dbits=32 abits=5 words=32
  Checking rule #1 for bram type $__XILINX_RAM32X1D (variant 1):
    Bram geometry: abits=5 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM32X1D: awaste=0 dwaste=0 bwaste=0 waste=0 efficiency=100
    Rule #1 for bram type $__XILINX_RAM32X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=0 efficiency=50
      Storing for later selection.
  Checking rule #2 for bram type $__XILINX_RAM64X1D (variant 1):
    Bram geometry: abits=6 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM64X1D: awaste=32 dwaste=0 bwaste=32 waste=32 efficiency=50
    Rule #2 for bram type $__XILINX_RAM64X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM64X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=64 efficiency=25
      Storing for later selection.
  Checking rule #3 for bram type $__XILINX_RAM128X1D (variant 1):
    Bram geometry: abits=7 dbits=1 wports=0 rports=0
    Estimated number of duplicates for more read ports: dups=1
    Metrics for $__XILINX_RAM128X1D: awaste=96 dwaste=0 bwaste=96 waste=96 efficiency=25
    Rule #3 for bram type $__XILINX_RAM128X1D (variant 1) accepted.
    Mapping to bram type $__XILINX_RAM128X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Updated properties: dups=2 waste=192 efficiency=12
      Storing for later selection.
  Selecting best of 3 rules:
    Efficiency for rule 3.1: efficiency=12, cells=64, acells=1
    Efficiency for rule 2.1: efficiency=25, cells=64, acells=1
    Efficiency for rule 1.1: efficiency=50, cells=64, acells=1
    Selected rule 1.1 with efficiency 50.
    Mapping to bram type $__XILINX_RAM32X1D (variant 1):
      Write port #0 is in clock domain \clk.
        Mapped to bram port B1.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Failed to map read port #1.
      Growing more read ports by duplicating bram cells.
      Read port #0 is in clock domain !~async~.
        Mapped to bram port A1.1.
      Read port #1 is in clock domain !~async~.
        Mapped to bram port A1.2.
      Creating $__XILINX_RAM32X1D cell at grid position <0 0 0>: Reg.0.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <0 0 1>: Reg.0.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <1 0 0>: Reg.1.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <1 0 1>: Reg.1.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <2 0 0>: Reg.2.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <2 0 1>: Reg.2.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <3 0 0>: Reg.3.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <3 0 1>: Reg.3.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <4 0 0>: Reg.4.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <4 0 1>: Reg.4.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <5 0 0>: Reg.5.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <5 0 1>: Reg.5.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <6 0 0>: Reg.6.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <6 0 1>: Reg.6.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <7 0 0>: Reg.7.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <7 0 1>: Reg.7.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <8 0 0>: Reg.8.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <8 0 1>: Reg.8.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <9 0 0>: Reg.9.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <9 0 1>: Reg.9.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <10 0 0>: Reg.10.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <10 0 1>: Reg.10.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <11 0 0>: Reg.11.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <11 0 1>: Reg.11.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <12 0 0>: Reg.12.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <12 0 1>: Reg.12.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <13 0 0>: Reg.13.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <13 0 1>: Reg.13.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <14 0 0>: Reg.14.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <14 0 1>: Reg.14.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <15 0 0>: Reg.15.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <15 0 1>: Reg.15.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <16 0 0>: Reg.16.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <16 0 1>: Reg.16.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <17 0 0>: Reg.17.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <17 0 1>: Reg.17.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <18 0 0>: Reg.18.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <18 0 1>: Reg.18.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <19 0 0>: Reg.19.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <19 0 1>: Reg.19.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <20 0 0>: Reg.20.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <20 0 1>: Reg.20.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <21 0 0>: Reg.21.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <21 0 1>: Reg.21.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <22 0 0>: Reg.22.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <22 0 1>: Reg.22.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <23 0 0>: Reg.23.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <23 0 1>: Reg.23.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <24 0 0>: Reg.24.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <24 0 1>: Reg.24.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <25 0 0>: Reg.25.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <25 0 1>: Reg.25.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <26 0 0>: Reg.26.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <26 0 1>: Reg.26.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <27 0 0>: Reg.27.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <27 0 1>: Reg.27.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <28 0 0>: Reg.28.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <28 0 1>: Reg.28.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <29 0 0>: Reg.29.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <29 0 1>: Reg.29.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <30 0 0>: Reg.30.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <30 0 1>: Reg.30.0.1
      Creating $__XILINX_RAM32X1D cell at grid position <31 0 0>: Reg.31.0.0
      Creating $__XILINX_RAM32X1D cell at grid position <31 0 1>: Reg.31.0.1

5.9. Executing TECHMAP pass (map to technology primitives).

5.9.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/drams_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/drams_map.v' to AST representation.
Generating RTLIL representation for module `\$__XILINX_RAM32X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM64X1D'.
Generating RTLIL representation for module `\$__XILINX_RAM128X1D'.
Successfully finished Verilog frontend.

5.9.2. Continuing TECHMAP pass.
Using template $paramod\$__XILINX_RAM32X1D\INIT=0\CLKPOL2=1 for cells of type $__XILINX_RAM32X1D.
No more expansions possible.
<suppressed ~75 debug messages>

5.10. Executing PMUX2SHIFTX pass.
Inspecting $pmux cell alu/$procmux$484.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: 4'1000
      1: 2'10 -> 2'10 -> 2'10: 4'0100
      2: 2'01 -> 2'01 -> 2'01: 4'0010
      3: 2'00 -> 2'00 -> 2'00: 4'0001
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$976.
Inspecting $pmux cell alu/$procmux$525.
  data width: 8 (next power-of-2 = 8, log2 = 3)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: \drdata [31:24]
      1: 2'10 -> 2'10 -> 2'10: \drdata [23:16]
      2: 2'01 -> 2'01 -> 2'01: \drdata [15:8]
      3: 2'00 -> 2'00 -> 2'00: \drdata [7:0]
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$978.
Inspecting $pmux cell alu/$procmux$572.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \daddr [1:0]
    best permutation: \daddr [1:0]
    best xor mask: 2'00
      0: 2'11 -> 2'11 -> 2'11: { \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31:24] }
      1: 2'10 -> 2'10 -> 2'10: { \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23] \drdata [23:16] }
      2: 2'01 -> 2'01 -> 2'01: { \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15:8] }
      3: 2'00 -> 2'00 -> 2'00: { \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7] \drdata [7:0] }
    choices: 4
    min choice: 0
    max choice: 3
    range density: 100%
    absolute density: 100%
    full density: 100%
    update to full case.
    new min choice: 0
    new max choice: 3
    full case: true
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$980.
Inspecting $pmux cell alu/$procmux$605.
  data width: 4 (next power-of-2 = 4, log2 = 2)
  checking ctrl signal \op
    best permutation: \op
    best xor mask: 6'011000
      0: 6'011010 -> 6'011010 -> 6'000010: 4'1111
      1: 6'011001 -> 6'011001 -> 6'000001: $3\dwe[3:0]
      2: 6'011000 -> 6'011000 -> 6'000000: $2\dwe[3:0]
    choices: 3
    min choice: 0
    max choice: 2
    range density: 100%
    absolute density: 100%
    full density: 4%
    full case: false
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$986.
Inspecting $pmux cell alu/$procmux$610.
  data width: 32 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \op
    best permutation: \op
    best xor mask: 6'000000
      0: 6'100100 -> 6'100100 -> 6'100100: $add$alu.v:106$46_Y
      1: 6'100011 -> 6'100011 -> 6'100011: { \instr [31:12] 12'000000000000 }
      3: 6'010111 -> 6'010111 -> 6'010111: { 16'0000000000000000 $5\rvout[31:0] }
      4: 6'010110 -> 6'010110 -> 6'010110: { 24'000000000000000000000000 $4\rvout[31:0] }
      5: 6'010101 -> 6'010101 -> 6'010101: \drdata
      6: 6'010100 -> 6'010100 -> 6'010100: $3\rvout[31:0]
      7: 6'010011 -> 6'010011 -> 6'010011: $2\rvout[31:0]
     17: 6'001001 -> 6'001001 -> 6'001001: $sub$alu.v:36$34_Y
    choices: 8
    min choice: 9
    max choice: 36
    range density: 28%
    absolute density: 21%
    full case: false
    insufficient density.
Inspecting $pmux cell cpu/$procmux$640.
  data width: 31 (next power-of-2 = 32, log2 = 5)
  checking ctrl signal \op
    best permutation: \op
    best xor mask: 6'000000
      0: 6'100010 -> 6'100010 -> 6'100010: $add$cpu.v:94$22_Y [31:1]
      1: 6'100001 -> 6'100001 -> 6'100001: $add$cpu.v:93$21_Y [31:1]
      2: 6'100000 -> 6'100000 -> 6'100000: $procmux$644_Y
      3: 6'011111 -> 6'011111 -> 6'011111: $procmux$648_Y
      4: 6'011110 -> 6'011110 -> 6'011110: $procmux$652_Y
      5: 6'011101 -> 6'011101 -> 6'011101: $procmux$656_Y
      6: 6'011100 -> 6'011100 -> 6'011100: $procmux$660_Y
      7: 6'011011 -> 6'011011 -> 6'011011: $procmux$664_Y
    choices: 8
    min choice: 27
    max choice: 34
    range density: 100%
    absolute density: 22%
    full density: 12%
    full case: false
    offset: 6'011011
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$992.
Inspecting $pmux cell cpu/$procmux$671.
  data width: 1 (next power-of-2 = 1, log2 = 0)
  checking ctrl signal \op
    best permutation: \op
    best xor mask: 6'000000
      0: 6'100010 -> 6'100010 -> 6'100010: 1'0
      1: 6'100001 -> 6'100001 -> 6'100001: $add$cpu.v:93$21_Y [0]
      2: 6'100000 -> 6'100000 -> 6'100000: $procmux$675_Y
      3: 6'011111 -> 6'011111 -> 6'011111: $procmux$679_Y
      4: 6'011110 -> 6'011110 -> 6'011110: $procmux$683_Y
      5: 6'011101 -> 6'011101 -> 6'011101: $procmux$687_Y
      6: 6'011100 -> 6'011100 -> 6'011100: $procmux$691_Y
      7: 6'011011 -> 6'011011 -> 6'011011: $procmux$695_Y
    choices: 8
    min choice: 27
    max choice: 34
    range density: 100%
    absolute density: 22%
    full density: 12%
    full case: false
    offset: 6'011011
    created $shiftx cell $auto$pmux2shiftx.cc:720:execute$998.
Inspecting $pmux cell dummydecoder/$procmux$318.
  data width: 6 (next power-of-2 = 8, log2 = 3)
  checking ctrl signal \instr [6:0]
    best permutation: { \instr [2:0] \instr [6:3] }
    best xor mask: 7'1110000
      0: 7'0010111 -> 7'1110010 -> 7'0000010: 6'100100
      1: 7'0110111 -> 7'1110110 -> 7'0000110: 6'100011
      2: 7'1101111 -> 7'1111101 -> 7'0001101: 6'100001
    choices: 3
    min choice: 2
    max choice: 13
    range density: 25%
    absolute density: 21%
    full density: 2%
    full case: false
    insufficient density.
Inspecting $pmux cell dummydecoder/$procmux$422.
  data width: 6 (next power-of-2 = 8, log2 = 3)
  checking ctrl signal { \instr [14:12] \instr [6:0] }
    best permutation: { \instr [3] \instr [1:0] \instr [14:12] \instr [6:4] \instr [2] }
    best xor mask: 10'0110000000
      0: 10'0001100111 -> 10'0110001101 -> 10'0000001101: 6'100010
      1: 10'1111100011 -> 10'0111111100 -> 10'0001111100: 6'100000
      2: 10'1101100011 -> 10'0111101100 -> 10'0001101100: 6'011111
      3: 10'1011100011 -> 10'0111011100 -> 10'0001011100: 6'011110
      4: 10'1001100011 -> 10'0111001100 -> 10'0001001100: 6'011101
      5: 10'0011100011 -> 10'0110011100 -> 10'0000011100: 6'011100
      6: 10'0001100011 -> 10'0110001100 -> 10'0000001100: 6'011011
      7: 10'0100100011 -> 10'0110100100 -> 10'0000100100: 6'011010
      8: 10'0010100011 -> 10'0110010100 -> 10'0000010100: 6'011001
      9: 10'0000100011 -> 10'0110000100 -> 10'0000000100: 6'011000
     10: 10'1010000011 -> 10'0111010000 -> 10'0001010000: 6'010111
     11: 10'1000000011 -> 10'0111000000 -> 10'0001000000: 6'010110
     12: 10'0100000011 -> 10'0110100000 -> 10'0000100000: 6'010101
     13: 10'0010000011 -> 10'0110010000 -> 10'0000010000: 6'010100
     14: 10'0000000011 -> 10'0110000000 -> 10'0000000000: 6'010011
     15: 10'1110110011 -> 10'0111110110 -> 10'0001110110: 6'010010
     16: 10'1100110011 -> 10'0111100110 -> 10'0001100110: 6'010001
     17: 10'1010110011 -> 10'0111010110 -> 10'0001010110: { 1'0 $auto$wreduce.cc:455:run$753 [4:0] }
     18: 10'1000110011 -> 10'0111000110 -> 10'0001000110: 6'001110
     19: 10'0110110011 -> 10'0110110110 -> 10'0000110110: 6'001101
     20: 10'0100110011 -> 10'0110100110 -> 10'0000100110: 6'001100
     21: 10'0010110011 -> 10'0110010110 -> 10'0000010110: 6'001011
     22: 10'0000110011 -> 10'0110000110 -> 10'0000000110: { 4'0010 $auto$wreduce.cc:455:run$752 [1:0] }
     23: 10'1010010011 -> 10'0111010010 -> 10'0001010010: { 2'00 $auto$wreduce.cc:455:run$751 [3:0] }
     24: 10'0010010011 -> 10'0110010010 -> 10'0000010010: 6'000110
     25: 10'1110010011 -> 10'0111110010 -> 10'0001110010: 6'000101
     26: 10'1100010011 -> 10'0111100010 -> 10'0001100010: 6'000100
     27: 10'1000010011 -> 10'0111000010 -> 10'0001000010: 6'000011
     28: 10'0110010011 -> 10'0110110010 -> 10'0000110010: 6'000010
     29: 10'0100010011 -> 10'0110100010 -> 10'0000100010: 6'000001
     30: 10'0000010011 -> 10'0110000010 -> 10'0000000010: 6'000000
    choices: 31
    min choice: 0
    max choice: 124
    range density: 24%
    absolute density: 24%
    full density: 3%
    full case: false
    insufficient density.

5.11. Executing OPT pass (performing simple optimizations).

5.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
<suppressed ~4 debug messages>
Optimizing module cpu.
<suppressed ~2 debug messages>
Optimizing module dummydecoder.
<suppressed ~1 debug messages>
Optimizing module regfile.
<suppressed ~2 debug messages>

5.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
<suppressed ~6 debug messages>
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 2 cells.

5.11.3. Executing OPT_RMDFF pass (remove dff with constant values).

5.11.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 11 unused cells and 466 unused wires.
<suppressed ~15 debug messages>

5.11.5. Finished fast OPT passes.

5.12. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

5.13. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

5.14. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Transforming FF to FF+Enable cells in module alu:
Transforming FF to FF+Enable cells in module cpu:
Transforming FF to FF+Enable cells in module dummydecoder:
Transforming FF to FF+Enable cells in module regfile:

5.15. Executing OPT pass (performing simple optimizations).

5.15.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.15.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.15.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~24 debug messages>

5.15.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
    Consolidated identical input bits for $mux cell $procmux$467:
      Old ports: A=4'0011, B=4'1100, Y=$3\dwe[3:0]
      New ports: A=2'01, B=2'10, Y={ $3\dwe[3:0] [2] $3\dwe[3:0] [0] }
      New connections: { $3\dwe[3:0] [3] $3\dwe[3:0] [1] } = { $3\dwe[3:0] [2] $3\dwe[3:0] [0] }
    Consolidated identical input bits for $mux cell $procmux$550:
      Old ports: A={ \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15] \drdata [15:0] }, B={ \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31] \drdata [31:16] }, Y=$3\rvout[31:0]
      New ports: A=\drdata [15:0], B=\drdata [31:16], Y=$3\rvout[31:0] [15:0]
      New connections: $3\rvout[31:0] [31:16] = { $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] $3\rvout[31:0] [15] }
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
    Consolidated identical input bits for $pmux cell $procmux$318:
      Old ports: A=6'000000, B=18'100001100011100100, Y=$2\op[5:0]
      New ports: A=4'0000, B=12'100110111100, Y={ $2\op[5:0] [5] $2\op[5:0] [2:0] }
      New connections: $2\op[5:0] [4:3] = 2'00
    Consolidated identical input bits for $mux cell $ternary$dummydecoder.v:23$49:
      Old ports: A=4'1000, B=4'0111, Y=$auto$wreduce.cc:455:run$751 [3:0]
      New ports: A=2'10, B=2'01, Y={ $auto$wreduce.cc:455:run$751 [3] $auto$wreduce.cc:455:run$751 [0] }
      New connections: $auto$wreduce.cc:455:run$751 [2:1] = { $auto$wreduce.cc:455:run$751 [0] $auto$wreduce.cc:455:run$751 [0] }
    Consolidated identical input bits for $mux cell $ternary$dummydecoder.v:29$51:
      Old ports: A=5'10000, B=5'01111, Y=$auto$wreduce.cc:455:run$753 [4:0]
      New ports: A=2'10, B=2'01, Y={ $auto$wreduce.cc:455:run$753 [4] $auto$wreduce.cc:455:run$753 [0] }
      New connections: $auto$wreduce.cc:455:run$753 [3:1] = { $auto$wreduce.cc:455:run$753 [0] $auto$wreduce.cc:455:run$753 [0] $auto$wreduce.cc:455:run$753 [0] }
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
Performed a total of 5 changes.

5.15.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
<suppressed ~3 debug messages>
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
<suppressed ~6 debug messages>
Finding identical cells in module `\regfile'.
Removed a total of 3 cells.

5.15.6. Executing OPT_RMDFF pass (remove dff with constant values).

5.15.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 0 unused cells and 3 unused wires.
<suppressed ~2 debug messages>

5.15.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.15.9. Rerunning OPT passes. (Maybe there is more to do..)

5.15.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \cpu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \dummydecoder..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \regfile..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~24 debug messages>

5.15.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \alu.
  Optimizing cells in module \cpu.
  Optimizing cells in module \dummydecoder.
  Optimizing cells in module \regfile.
Performed a total of 0 changes.

5.15.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
Finding identical cells in module `\cpu'.
Finding identical cells in module `\dummydecoder'.
Finding identical cells in module `\regfile'.
Removed a total of 0 cells.

5.15.13. Executing OPT_RMDFF pass (remove dff with constant values).

5.15.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..

5.15.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
Optimizing module cpu.
Optimizing module dummydecoder.
Optimizing module regfile.

5.15.16. Finished OPT passes. (There is nothing left to do.)

5.16. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping cpu.$procdff$716 ($dff).

5.17. Executing SHREGMAP pass (map shift registers).
Converted 0 dff cells into 0 shift registers.

5.18. Executing TECHMAP pass (map to technology primitives).

5.18.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

5.18.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/arith_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_xilinx_lcu'.
Generating RTLIL representation for module `\_80_xilinx_alu'.
Successfully finished Verilog frontend.

5.18.3. Continuing TECHMAP pass.
Running "alumacc" on wrapper $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=6:B_SIGNED=0:B_WIDTH=6:Y_WIDTH=6:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=6:B_SIGNED=0:B_WIDTH=6:Y_WIDTH=6:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:A_SIGNED=0:A_WIDTH=6:B_SIGNED=0:B_WIDTH=6:Y_WIDTH=6:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $paramod$bf3b5fab9e093d19bbea16c6516a73d098dbaa75\_80_xilinx_alu for cells of type $alu.
Using template $paramod$constmap:17635e53697fdbe6124eb62cf3263c8047ce714f$paramod$ca37ad691ff513409e4db4e648f07689bd3600ea\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:5b087f626323c7186e3b3e405bd5686fb7eaf317$paramod$c38f2bb851ab04d55eeaee8fb94dabe3050d2157\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:f887d146485091376dc224d2622f0240ae9d020e$paramod$33cf24f9667d6bd722e0eaade47bd9bad0a93c70\_90_shift_shiftx for cells of type $shift.
Using template $paramod$ed0e7b60ee0d374b6722444b11ce7533faf826e2\_80_xilinx_alu for cells of type $alu.
Using extmapper simplemap for cells of type $reduce_and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $reduce_or.
Using template $paramod$719b7377ef9ef9687a4f925f8696c903232706da\_80_xilinx_alu for cells of type $alu.
Using template $paramod$2827e7d34c07400d403bef957360fef4bde6a36b\_80_xilinx_alu for cells of type $alu.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $pos.
Using template $paramod$223c94788d94f60aaf4a0e02248275476901306c\_80_xilinx_alu for cells of type $alu.
Using template $paramod$constmap:4621fcf06a436d1e2a4080e2ed9866a7d07a6e07$paramod$887c9fe2c55be14c90171bd2ff359c086a0858d7\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shl.
Using template $paramod$constmap:4621fcf06a436d1e2a4080e2ed9866a7d07a6e07$paramod$943af4e63d02cf420cf82d17400bd04ea07088b0\_90_shift_ops_shr_shl_sshl_sshr for cells of type $sshr.
Using template $paramod$constmap:4621fcf06a436d1e2a4080e2ed9866a7d07a6e07$paramod$770435fdf938ca78b5f1ecab2552fff9f675f686\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shr.
Using template $paramod$constmap:9e347b6cde10797733eb0594cb3cba55be16a926$paramod$c16c78428b8b9082f59a5499dd54d1672626d3c1\_90_shift_shiftx for cells of type $shift.
Using template $paramod$constmap:cfe18f9dcbf321cb6311994a8efc1e30675937c3$paramod$7293aed416beb8760e5389a199e73fea480f82b9\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:4e5a05ced4239ad41356ad3d10ba347228467d61$paramod$382409730955a3e0658e1099b9ffc977899f50ec\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:e7214e8bd05a28e58319966b0df5f8236d0271c3$paramod$9852e737f52c689a5201940ede7b10a925704df2\_90_shift_shiftx for cells of type $shiftx.
Using template $paramod$constmap:ad62432dc588384ac9e4502cee6ddae521345b24$paramod$616bc737fc20a0b56f184bcda6509db70a8b8664\_90_shift_shiftx for cells of type $shiftx.
Using extmapper simplemap for cells of type $eq.
Using template $paramod\_90_pmux\WIDTH=32\S_WIDTH=18 for cells of type $pmux.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $reduce_bool.
Using template $paramod\_90_pmux\WIDTH=32\S_WIDTH=2 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=4\S_WIDTH=3 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=1\S_WIDTH=2 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=6\S_WIDTH=31 for cells of type $pmux.
No more expansions possible.
<suppressed ~3014 debug messages>

5.19. Executing OPT pass (performing simple optimizations).

5.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module alu.
<suppressed ~660 debug messages>
Optimizing module cpu.
<suppressed ~315 debug messages>
Optimizing module dummydecoder.
<suppressed ~526 debug messages>
Optimizing module regfile.
<suppressed ~89 debug messages>

5.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\alu'.
<suppressed ~2493 debug messages>
Finding identical cells in module `\cpu'.
<suppressed ~774 debug messages>
Finding identical cells in module `\dummydecoder'.
<suppressed ~1311 debug messages>
Finding identical cells in module `\regfile'.
<suppressed ~405 debug messages>
Removed a total of 1661 cells.

5.19.3. Executing OPT_RMDFF pass (remove dff with constant values).

5.19.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \alu..
Finding unused cells or wires in module \cpu..
Finding unused cells or wires in module \dummydecoder..
Finding unused cells or wires in module \regfile..
Removed 881 unused cells and 1073 unused wires.
<suppressed ~885 debug messages>

5.19.5. Finished fast OPT passes.

5.20. Executing TECHMAP pass (map to technology primitives).

5.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

5.20.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Successfully finished Verilog frontend.

5.20.3. Continuing TECHMAP pass.
No more expansions possible.

5.21. Executing ABC pass (technology mapping using ABC).

5.21.1. Extracting gate netlist of module `\alu' to `<abc-temp-dir>/input.blif'..
Extracted 1837 gates and 2117 wires to a netlist network with 277 inputs and 298 outputs.

5.21.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

5.21.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:     1378
ABC RESULTS:        internal signals:     1542
ABC RESULTS:           input signals:      277
ABC RESULTS:          output signals:      298
Removing temp directory.

5.21.2. Extracting gate netlist of module `\cpu' to `<abc-temp-dir>/input.blif'..
Extracted 1095 gates and 1426 wires to a netlist network with 328 inputs and 317 outputs.

5.21.2.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

5.21.2.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      912
ABC RESULTS:        internal signals:      781
ABC RESULTS:           input signals:      328
ABC RESULTS:          output signals:      317
Removing temp directory.

5.21.3. Extracting gate netlist of module `\dummydecoder' to `<abc-temp-dir>/input.blif'..
Extracted 300 gates and 356 wires to a netlist network with 54 inputs and 39 outputs.

5.21.3.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

5.21.3.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      176
ABC RESULTS:        internal signals:      263
ABC RESULTS:           input signals:       54
ABC RESULTS:          output signals:       39
Removing temp directory.

5.21.4. Extracting gate netlist of module `\regfile' to `<abc-temp-dir>/input.blif'..
Extracted 250 gates and 377 wires to a netlist network with 125 inputs and 106 outputs.

5.21.4.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: Currently "mfs" cannot process the network containing nodes with more than 6 fanins.
ABC: + write_blif <abc-temp-dir>/output.blif 

5.21.4.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      212
ABC RESULTS:        internal signals:      146
ABC RESULTS:           input signals:      125
ABC RESULTS:          output signals:      106
Removing temp directory.
Removed 0 unused cells and 1232 unused wires.

5.22. Executing SHREGMAP pass (map shift registers).
Converted 0 dff cells into 0 shift registers.

5.23. Executing TECHMAP pass (map to technology primitives).

5.23.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/lut_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/lut_map.v' to AST representation.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

5.23.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/ff_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/ff_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Successfully finished Verilog frontend.

5.23.3. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/xilinx/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/xilinx/cells_map.v' to AST representation.
Generating RTLIL representation for module `\_90_dff_nn0_to_np0'.
Generating RTLIL representation for module `\_90_dff_pn0_to_pp0'.
Generating RTLIL representation for module `\_90_dff_nn1_to_np1'.
Generating RTLIL representation for module `\_90_dff_pn1_to_pp1'.
Generating RTLIL representation for module `\$__SHREG_'.
Generating RTLIL representation for module `\$__XILINX_SHREG_'.
Successfully finished Verilog frontend.

5.23.4. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=2\LUT=4'1001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10101100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10010110 for cells of type $lut.
Using template $paramod$33a8b4c8a84ca536dbdd4fea6c96842757b1a355\$lut for cells of type $lut.
Using template $paramod$fd981d57d953ba8dcac298d3386c951aac959b56\$lut for cells of type $lut.
Using template $paramod$55be19044b6e4c4d8aa2d0e4f66b021936124459\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00000001 for cells of type $lut.
Using template $paramod$3b6dd15e29ea6a6e46b48692ebd3605ed70de7e5\$lut for cells of type $lut.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
Using template $paramod$cbff2b89c1507cb1100c4f1b6e9ab183ccb99c01\$lut for cells of type $lut.
Using template $paramod$f5ab3c020906fd8937f5207c682c3125ce000295\$lut for cells of type $lut.
Using template $paramod$57cb2b0bf5e1bef90955e23f97343a89107ce32a\$lut for cells of type $lut.
Using template $paramod$70f582d5d97500ab3116d70392e6577b7526c1a4\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0110 for cells of type $lut.
Using template $paramod$3da916e1c5705810970d14a41b8c266d3136a8ba\$lut for cells of type $lut.
Using template $paramod$6d2bb33e862439fd81958f840698569790b84499\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011010100110011 for cells of type $lut.
Using template $paramod$6770de80e8888b597d9afef8fa22cb63af8d0fa8\$lut for cells of type $lut.
Using template $paramod$cf56ffd6d2e919649ada2f94bd76ca3774f33ffb\$lut for cells of type $lut.
Using template $paramod$a6af51c82e63e9f07864cd09c6413d52aeeacfcd\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=268435456 for cells of type $lut.
Using template $paramod$269d47a5fbf4a0ede26ab65e75e827a77cdd7263\$lut for cells of type $lut.
Using template $paramod$764b54c448dc6d3451cf5677e27c53aa9b38192e\$lut for cells of type $lut.
Using template $paramod$415a62358290b70884679c86908ca13925457cd5\$lut for cells of type $lut.
Using template $paramod$c80f7b066110b96fc5269c47430c460ec6fae038\$lut for cells of type $lut.
Using template $paramod$5179a8f8caf67f8ce8349a768ac0e8af8178b5b8\$lut for cells of type $lut.
Using template $paramod$a662edae60b32919c7e107b38071f6afe9c0230f\$lut for cells of type $lut.
Using template $paramod$85cab5ba11ebdfab005a4ab406988f1b3f0dd9b5\$lut for cells of type $lut.
Using template $paramod$190c1eb6625f8032b16b3e629910dc099fd508bc\$lut for cells of type $lut.
Using template $paramod$db5a5f9d146a6d38b278c191b50ad4bbf4493ac2\$lut for cells of type $lut.
Using template $paramod$8fd74d83b61d2a86993b1ca2f7617665c11b44fd\$lut for cells of type $lut.
Using template $paramod$2372381f45d474b3eb5c787077cd8c0e73353efe\$lut for cells of type $lut.
Using template $paramod$1929d44748517239e36a599c0facfb62ddb99607\$lut for cells of type $lut.
Using template $paramod$a4d62fd9b11586568011dc904e87347350a6719e\$lut for cells of type $lut.
Using template $paramod$45d6f9a0885c25177863b812679445a28a1ab7e1\$lut for cells of type $lut.
Using template $paramod$22741b0f73190214fdad6daad9402290f8a9f996\$lut for cells of type $lut.
Using template $paramod$2ce3eab6f3d5647f7f9cbc34a26c64b53ee2c255\$lut for cells of type $lut.
Using template $paramod$c9d9978aeeaf5de3902d98b218fa214a8792c451\$lut for cells of type $lut.
Using template $paramod$b98a4247e0ef66f75fe6f7f094c35c57167a6b7c\$lut for cells of type $lut.
Using template $paramod$bcfd7f96dd271aa4cf80e3d9cf008194fc139a98\$lut for cells of type $lut.
Using template $paramod$7a937ab2991904c32975d7e5c711e57c3e98b269\$lut for cells of type $lut.
Using template $paramod$af576d359a99fbcf5eb662d6611abb8f0be880f0\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=201981952 for cells of type $lut.
Using template $paramod$d099bee453e498387188b4b40c4b3142fe4bd944\$lut for cells of type $lut.
Using template $paramod$13d82fb6a7bdb6dffada90fcb4e9f82029a2398e\$lut for cells of type $lut.
Using template $paramod$e4410f6068ac195e7117d07a11f0b8cdeea2c9e5\$lut for cells of type $lut.
Using template $paramod$07c03b2fae8e136029152a0dfd4c2179b5c9c0e6\$lut for cells of type $lut.
Using template $paramod$8a85612764fbe210048f715045c903058ff7bb71\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=250478592 for cells of type $lut.
Using template $paramod$7281ae1a37185e868a7ad4657bd33151908d1079\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01000000 for cells of type $lut.
Using template $paramod$878a50e4ef048c92d9a63e90b0916bbd598cf5d1\$lut for cells of type $lut.
Using template $paramod$eaf900848921d8a66bdc5681b00890eb328948f3\$lut for cells of type $lut.
Using template $paramod$597ea396e961654323fde45bb7095cebf7b16497\$lut for cells of type $lut.
Using template $paramod$cd6dc331fb5076546c2b1694e7fad7ce6b2a35d2\$lut for cells of type $lut.
Using template $paramod$cd66920932c8c68cd68add5d19c14192f00ccb5a\$lut for cells of type $lut.
Using template $paramod$786b97c82a06f8b1aa782a266f64e0c900297d8b\$lut for cells of type $lut.
Using template $paramod$438b2f779539d5e9bebfbfec154422a6627e86eb\$lut for cells of type $lut.
Using template $paramod$8d1ec45a2dad7ef3041ea4f2fc429b54299d27f3\$lut for cells of type $lut.
Using template $paramod$9fa7e98030cf361fad70c8889d42c174c9f37107\$lut for cells of type $lut.
Using template $paramod$2bac80565acef9f941e631e96f4bde4974bad44e\$lut for cells of type $lut.
Using template $paramod$f2e37bd621b459ef9fc9b8d3cfa8a97aba013b5e\$lut for cells of type $lut.
Using template $paramod$9bad965bb2ffeb48b4984144ff41c8668144ee11\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0001 for cells of type $lut.
Using template $paramod$bcf5d5175c2f96809ed844350bb8d004784d4c4a\$lut for cells of type $lut.
Using template $paramod$3b302d5ab2ba81d2d4a86a2ec851d3f81e4b0591\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=825292287 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000011101110111 for cells of type $lut.
Using template $paramod$240689eae262def78c1e1c9cb7df0c7c4c03e9e0\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000110000001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100010100000000 for cells of type $lut.
Using template $paramod$e7c531e78382610e92a43dcf4163e72e3d3709a2\$lut for cells of type $lut.
Using template $paramod$1362db2153b33cd783e5b5a9eed42a5e36d59ee9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011101110110000 for cells of type $lut.
Using template $paramod$43813856479f4cbe5ff5b3e55f04a5b8b30ad938\$lut for cells of type $lut.
Using template $paramod$744a9756dd4fc038df0cfd521d36a5c19225a876\$lut for cells of type $lut.
Using template $paramod$840bac760297ea49c847dd92c30427d353c071b6\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111001100110000111101010101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011010100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=786442 for cells of type $lut.
Using template $paramod$51b9391336e0b21359d49288ac1fb7f602d33da9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0111011101110000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00010000 for cells of type $lut.
Using template $paramod$d15af38450e5229bdf72465b6576507ad85daea7\$lut for cells of type $lut.
Using template $paramod$4683b15c6cedb74b43712fb7c353ce4bb8251cc4\$lut for cells of type $lut.
Using template $paramod$95d359d470e8c73b0cbf98b4d0dcf41c00344666\$lut for cells of type $lut.
Using template $paramod$09a9f5f53595c52729540f1d881ba300b7ec9703\$lut for cells of type $lut.
Using template $paramod$90ba2774091e0903a9c3ece5c907846b85b12156\$lut for cells of type $lut.
Using template $paramod$724be6a603e0301ce14b35df42a6b6cc7695e424\$lut for cells of type $lut.
Using template $paramod$9c1fdb72bfab429eb035e50b86046f0edb412905\$lut for cells of type $lut.
Using template $paramod$e5e36b85be3bbe4d92478021c16dbf6535d3bccc\$lut for cells of type $lut.
Using template $paramod$da5ac4dc3dc9b97c79c3617bd511fda58c3fb3cb\$lut for cells of type $lut.
Using template $paramod$d5c013b77b78b3ec2d321f21957799cc89fff543\$lut for cells of type $lut.
Using template $paramod$3e45b9f56d0cc2d208ccdd8f01b3e4f9fd3d6628\$lut for cells of type $lut.
Using template $paramod$56f3e246421b6b29fd066d86d01fc72a1f44c94f\$lut for cells of type $lut.
Using template $paramod$65d1d47e2510064b2744e29e5cfb0e106fd2e1fd\$lut for cells of type $lut.
Using template $paramod$68199c08e4edd9358bc9810a9d4c74658e08f38a\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00001101 for cells of type $lut.
Using template $paramod$1c18086a1a69632c4807af39f0454c5dde26ea52\$lut for cells of type $lut.
Using template $paramod$47b3c777a0b59812c90ef4d44434e344371df02c\$lut for cells of type $lut.
Using template $paramod$495b3879529ec10761d28aadc0923cd3deadd2c3\$lut for cells of type $lut.
Using template $paramod$e49315cbea6f67a526219825c7edf799e1f51f2c\$lut for cells of type $lut.
Using template $paramod$554053da23292acb0d92db030e40a1bcc1ebf301\$lut for cells of type $lut.
Using template $paramod$345139d8ff3d2af207c8bfa75465819239ec962e\$lut for cells of type $lut.
Using template $paramod$eebe53f3edce8087caa46aa2f67aaf6b1494ef23\$lut for cells of type $lut.
Using template $paramod$4b65c95aa96ffef51e17062ec6091da4a15e76a7\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0111000001110111 for cells of type $lut.
Using template $paramod$9683cc9d8c279fa98b0abd64755cb1b3e2c68cb9\$lut for cells of type $lut.
Using template $paramod$2ad3520a2310376e103f641d206b07165f13fe42\$lut for cells of type $lut.
Using template $paramod$29a77164598d04fbc2afefa056ebc3fa0edf0d82\$lut for cells of type $lut.
Using template $paramod$8cf9325fc33eb66f99c9d1b9bea799e1a5cad6bc\$lut for cells of type $lut.
Using template $paramod$018863437cef7c4756afdff73462f96b4057696e\$lut for cells of type $lut.
Using template $paramod$f6911cf108a4df89c75c9b82ae7f908be1d48942\$lut for cells of type $lut.
Using template $paramod$a3d3d8cf95ee4eb532ddd9037decdce6e5b0d2aa\$lut for cells of type $lut.
Using template $paramod$1fe9e41cf88b5a2352df12f461128d4e1ecbff15\$lut for cells of type $lut.
Using template $paramod$f642dacad27344c7807a4a23a1e31a9a155361b6\$lut for cells of type $lut.
Using template $paramod$ad0c57f2e3b5fab1895fb50d4ba4c0eb1c4f805a\$lut for cells of type $lut.
Using template $paramod$95c6a64df76131b90399696387f6e4430aa0bf89\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111000011110001000100000001 for cells of type $lut.
Using template $paramod$2fb7398e628b5ac406a34b515d08b3901ec627ef\$lut for cells of type $lut.
Using template $paramod$d332c140cb4923288068d8a82e6bd6c03cf3cbdd\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00110101 for cells of type $lut.
Using template $paramod$d7911272bea838c142c19432a3edc2c409613630\$lut for cells of type $lut.
Using template $paramod$2670bcec6bcd999ece4d0714436aee323a4713d4\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111010000000000000000000000 for cells of type $lut.
Using template $paramod$591ad3dd8b32445b460b41dc8266dd95194e77f5\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1011000010111011 for cells of type $lut.
Using template $paramod$ef1e86eb6057a6200051df6e9ae0a897019771a3\$lut for cells of type $lut.
Using template $paramod$ca70fff7f6cba4d7ac7c67313942e068956c9c68\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000001100000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=53167 for cells of type $lut.
Using template $paramod$263d7723219101fc1fd5d312b3d5ce2bd0320fc9\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=65536 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11010000 for cells of type $lut.
Using template $paramod$a8f2d6a9014b97d997701273ee783a9cd98bee4d\$lut for cells of type $lut.
Using template $paramod$0fccd06fa96637315c198d89795363c2f933a170\$lut for cells of type $lut.
Using template $paramod$5f4de9d105e67d1ba90d676a784bc243e6cd770e\$lut for cells of type $lut.
Using template $paramod$c04b9a572279cdc76f3225867a01e3272d21c100\$lut for cells of type $lut.
Using template $paramod$dfce8079a3fe0fd5ef3b1861772d64abf48b6cd1\$lut for cells of type $lut.
Using template $paramod$eaa58097b49db8aa7069d6822b681327c16748f9\$lut for cells of type $lut.
Using template $paramod$b728342c400011891934f4472c8626defc12a402\$lut for cells of type $lut.
Using template $paramod$66fab141aec60937b6aa2b356e44bc16ceec39c2\$lut for cells of type $lut.
Using template $paramod$e5eeb1173768b55d1d64c0b4b6d8491186ebaa26\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=125239296 for cells of type $lut.
Using template $paramod$d852db8339fe41332bef1c734fd5d3b2e239e3bd\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00000111 for cells of type $lut.
Using template $paramod$d91fa27463fe0d2063d028f291855bdedb4bd2e8\$lut for cells of type $lut.
Using template $paramod$f6b3c6d77d2a442103d0f39e8359510378c7c2ad\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=889192448 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000101100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'10111011000010110000000000000000 for cells of type $lut.
Using template $paramod$4fba18c4a1d14716fc1e36d227e3131e46713229\$lut for cells of type $lut.
Using template $paramod$e2a83180edeb10412781cf46d8123a0abd9a0895\$lut for cells of type $lut.
Using template $paramod$91069a94bdb825357a64d15555497b850dce24bc\$lut for cells of type $lut.
Using template $paramod$23b8035977be29a83ece129966f15680b144534a\$lut for cells of type $lut.
Using template $paramod$13d81c4ac66cbb9d13acf7d8d3a611d24dbd63a9\$lut for cells of type $lut.
Using template $paramod$05d40e7ada1d49167c6ef670f97aa78d1003b5ad\$lut for cells of type $lut.
Using template $paramod$9bb6976331afd65c04e14cb8cfe8c4b8604e21f6\$lut for cells of type $lut.
Using template $paramod$ca5b9d643f18ee9f4d15cf759b30604c2b406a60\$lut for cells of type $lut.
Using template $paramod$5984a8771ea367bd2dffe595fd2f9f201f66afd0\$lut for cells of type $lut.
Using template $paramod$d0418773823f918102d44b7c801be6c6eaf4b0ed\$lut for cells of type $lut.
Using template $paramod$a825c0e8fd98848d2414ed6a7dade7f06b47deb5\$lut for cells of type $lut.
Using template $paramod$a6abd944a4d99f4494a7641d50587949c0bf7a98\$lut for cells of type $lut.
Using template $paramod$473e6c5d5e822a7eb4e0230192e38535dd28ea78\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=1911 for cells of type $lut.
Using template $paramod$a3a808502dec7cdeb9e2af784ce1fa3e42d6b64a\$lut for cells of type $lut.
Using template $paramod$ff2f2bc477bede2d137bd7cf212930b5889c2931\$lut for cells of type $lut.
Using template $paramod$70dc388c461b7c8ab7242369ddcc37e9f81f200c\$lut for cells of type $lut.
Using template $paramod$3126902c87dd3f05eafeea593490bd792bae0033\$lut for cells of type $lut.
Using template $paramod$056cf2be4343a593759f827eff881c786498fd7e\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=1063190528 for cells of type $lut.
Using template $paramod$04579d5a7f7d11008d5c4dab02ae6edd004a19ac\$lut for cells of type $lut.
Using template $paramod$381547131086b3851e12a07d68ebf0b6f9ca0b6c\$lut for cells of type $lut.
Using template $paramod$a0615004df337e1efac84186cc639e0601a9dd42\$lut for cells of type $lut.
Using template $paramod$917a046cd33dba15e3699dccade0b7ba41936fb5\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000000000000 for cells of type $lut.
Using template $paramod$f6748d23f573343e76d1b150e7e919c6be52dde7\$lut for cells of type $lut.
Using template $paramod$f7e53483b2207a066a3f21ab6e756e91fe563f64\$lut for cells of type $lut.
Using template $paramod$e8a6fd62694f7eee8db502428efb14357c6b3cfe\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=84672512 for cells of type $lut.
Using template $paramod$f1ccf33c9a35050e52e1b47d9eab4e0adc3495e0\$lut for cells of type $lut.
Using template $paramod$9b260d495bf77e1d2bddab804fffe472b4d681d6\$lut for cells of type $lut.
Using template $paramod$2a63089887ebb421ddaa127bb91238d05fc46c3b\$lut for cells of type $lut.
Using template $paramod$23a97addd281376871d79b9e1967665a41fc366d\$lut for cells of type $lut.
Using template $paramod$2e07371e6b6877f01574556822a431fd9734cbb7\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111110111011111111111111111111 for cells of type $lut.
Using template $paramod$42150e5c55c30b91edfbeec9b82ff402af8fe1e6\$lut for cells of type $lut.
Using template $paramod$29684e3b49d47088b48871e1e0ec9f6c6f0ee342\$lut for cells of type $lut.
Using template $paramod$278dcc352d129de1b7dfdbdb1d4304062d9fd036\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111111110001111111111111111 for cells of type $lut.
Using template $paramod$45aab331f94ba68cb291f6c4ce87d7b16c83dc39\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0100010011110000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0100000000000000 for cells of type $lut.
Using template $paramod$d3854e401fe5b8b146829835823fbfb0b0c02108\$lut for cells of type $lut.
Using template $paramod$9d19f2ed85a5669d78de7273a3b8ab1361892380\$lut for cells of type $lut.
Using template $paramod$6d6a4bf8da48d9814e7f4c2ec683c2c6f306c31f\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11101111111111111111111111111111 for cells of type $lut.
Using template $paramod$9a6fef217e17b4f067cf2419420ee6529ca30755\$lut for cells of type $lut.
Using template $paramod$4df49764e9a33bd9c48cb6d19f9540db375b6f5e\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=125304831 for cells of type $lut.
Using template $paramod$d428543dece172ce91e5fd71bb20db3e495c9064\$lut for cells of type $lut.
Using template $paramod$94b7ca6151be686ddcd29823e8cedad911a1a6bd\$lut for cells of type $lut.
Using template $paramod$e66cc471b5df98af045e5a88d12e8d811847cf43\$lut for cells of type $lut.
Using template $paramod$e9fab1acf7d7681465b169592991228d3f724fe3\$lut for cells of type $lut.
Using template $paramod$2d6b902cc07bddf4d1d2058905de4296ac20c13d\$lut for cells of type $lut.
Using template $paramod$a810e6efb0bf3afb7614b660d0c1726a1818622f\$lut for cells of type $lut.
Using template $paramod$d875a5335493dacc3703cbd87c33fcb1fd336661\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000000000000000 for cells of type $lut.
Using template $paramod$9e78996d0bba598dd3b5c2b67f719222e5a16cfc\$lut for cells of type $lut.
Using template $paramod\$lut\WIDTH=5\LUT=32'11111111111100101111111111111111 for cells of type $lut.
Using template $paramod$801e8edb501aa8b5786e3fad78d3014a75291595\$lut for cells of type $lut.
No more expansions possible.
<suppressed ~3747 debug messages>

5.24. Executing DFFINIT pass (set INIT param on FF cells).
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1028.INIT (port=Q, net=\iaddr [29]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1004.INIT (port=Q, net=\iaddr [5]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$999.INIT (port=Q, net=\iaddr [0]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1003.INIT (port=Q, net=\iaddr [4]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1001.INIT (port=Q, net=\iaddr [2]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1000.INIT (port=Q, net=\iaddr [1]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1007.INIT (port=Q, net=\iaddr [8]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1005.INIT (port=Q, net=\iaddr [6]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1002.INIT (port=Q, net=\iaddr [3]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1006.INIT (port=Q, net=\iaddr [7]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1018.INIT (port=Q, net=\iaddr [19]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1027.INIT (port=Q, net=\iaddr [28]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1014.INIT (port=Q, net=\iaddr [15]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1008.INIT (port=Q, net=\iaddr [9]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1012.INIT (port=Q, net=\iaddr [13]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1013.INIT (port=Q, net=\iaddr [14]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1024.INIT (port=Q, net=\iaddr [25]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1010.INIT (port=Q, net=\iaddr [11]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1020.INIT (port=Q, net=\iaddr [21]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1011.INIT (port=Q, net=\iaddr [12]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1009.INIT (port=Q, net=\iaddr [10]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1019.INIT (port=Q, net=\iaddr [20]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1030.INIT (port=Q, net=\iaddr [31]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1016.INIT (port=Q, net=\iaddr [17]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1026.INIT (port=Q, net=\iaddr [27]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1017.INIT (port=Q, net=\iaddr [18]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1015.INIT (port=Q, net=\iaddr [16]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1025.INIT (port=Q, net=\iaddr [26]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1029.INIT (port=Q, net=\iaddr [30]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1022.INIT (port=Q, net=\iaddr [23]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1021.INIT (port=Q, net=\iaddr [22]) to 1'0.
Setting cpu.$auto$simplemap.cc:420:simplemap_dff$1023.INIT (port=Q, net=\iaddr [24]) to 1'0.
Removed 0 unused cells and 2774 unused wires.

5.25. Executing HIERARCHY pass (managing design hierarchy).

5.25.1. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \alu
Used module:     \regfile
Used module:     \dummydecoder

5.25.2. Analyzing design hierarchy..
Top module:  \cpu
Used module:     \alu
Used module:     \regfile
Used module:     \dummydecoder
Removed 0 unused modules.

5.26. Printing statistics.

=== alu ===

   Number of wires:               1275
   Number of wire bits:           1717
   Number of public wires:          10
   Number of public wire bits:     266
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1512
     LUT1                           65
     LUT2                          208
     LUT3                           15
     LUT4                           30
     LUT5                           24
     LUT6                          600
     MUXCY                         188
     MUXF7                         211
     MUXF8                          42
     XORCY                         129

   Estimated number of LCs:        771

=== cpu ===

   Number of wires:                653
   Number of wire bits:           1239
   Number of public wires:          20
   Number of public wire bits:     384
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                950
     FDRE                           32
     LUT1                            3
     LUT2                          283
     LUT3                           95
     LUT6                          141
     MUXCY                         193
     MUXF7                          55
     MUXF8                          11
     XORCY                         134
     alu                             1
     dummydecoder                    1
     regfile                         1

   Estimated number of LCs:        332

=== dummydecoder ===

   Number of wires:                 77
   Number of wire bits:            187
   Number of public wires:           8
   Number of public wire bits:     118
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                108
     LUT2                            9
     LUT3                           15
     LUT4                           33
     LUT5                            6
     LUT6                           35
     MUXF7                           8
     MUXF8                           2

   Estimated number of LCs:         89

=== regfile ===

   Number of wires:                344
   Number of wire bits:            640
   Number of public wires:          12
   Number of public wire bits:     215
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                488
     LUT2                           73
     LUT6                          129
     MUXCY                          62
     MUXF7                          64
     MUXF8                          32
     RAM32X1D                       64
     XORCY                          64

   Estimated number of LCs:        166

=== design hierarchy ===

   cpu                               1
     alu                             1
     dummydecoder                    1
     regfile                         1

   Number of wires:               2349
   Number of wire bits:           3783
   Number of public wires:          50
   Number of public wire bits:     983
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               3055
     FDRE                           32
     LUT1                           68
     LUT2                          573
     LUT3                          125
     LUT4                           63
     LUT5                           30
     LUT6                          905
     MUXCY                         443
     MUXF7                         338
     MUXF8                          87
     RAM32X1D                       64
     XORCY                         327

   Estimated number of LCs:       1335

5.27. Executing CHECK pass (checking for obvious problems).
checking module alu..
Warning: Wire alu.dwdata has an unprocessed 'init' attribute.
Warning: Wire alu.dwe has an unprocessed 'init' attribute.
checking module cpu..
checking module dummydecoder..
checking module regfile..
Warning: Wire regfile.daddr has an unprocessed 'init' attribute.
found and reported 3 problems.

6. Executing Verilog backend.
Dumping module `\alu'.
Dumping module `\cpu'.
Dumping module `\dummydecoder'.
Dumping module `\regfile'.

Warnings: 3 unique messages, 3 total
End of script. Logfile hash: c5626f85f5
CPU: user 6.75s system 0.24s, MEM: 180.20 MB total, 174.97 MB resident
Yosys 0.9 (git sha1 1979e0b)
Time spent: 18% 2x write_verilog (1 sec), 17% 21x read_verilog (1 sec), ...
Compiling sources for post-synthesis simulation
Ensure all required files listed in program_files_synth.txt
RUNNING TEST 
PASSED

Passed

You should see a PASS message and all tests pass.
If any test reports as a FAIL, fix it before submitting.
Once all tests pass, commit the changes into your code,
and push the commit back to the server for evaluation.
